// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: server.proto

package grep11

import (
	context "context"
	fmt "fmt"
	github_com_IBM_Cloud_hpcs_grep11_go_ep11 "github.com/IBM-Cloud/hpcs-grep11-go/ep11"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type RSAOAEPParm_Mask int32

const (
	RSAOAEPParm_CkgMgf1None   RSAOAEPParm_Mask = 0
	RSAOAEPParm_CkgMgf1Sha1   RSAOAEPParm_Mask = 1
	RSAOAEPParm_CkgMgf1Sha256 RSAOAEPParm_Mask = 2
	RSAOAEPParm_CkgMgf1Sha384 RSAOAEPParm_Mask = 3
	RSAOAEPParm_CkgMgf1Sha512 RSAOAEPParm_Mask = 4
	RSAOAEPParm_CkgMgf1Sha224 RSAOAEPParm_Mask = 5
)

var RSAOAEPParm_Mask_name = map[int32]string{
	0: "CkgMgf1None",
	1: "CkgMgf1Sha1",
	2: "CkgMgf1Sha256",
	3: "CkgMgf1Sha384",
	4: "CkgMgf1Sha512",
	5: "CkgMgf1Sha224",
}

var RSAOAEPParm_Mask_value = map[string]int32{
	"CkgMgf1None":   0,
	"CkgMgf1Sha1":   1,
	"CkgMgf1Sha256": 2,
	"CkgMgf1Sha384": 3,
	"CkgMgf1Sha512": 4,
	"CkgMgf1Sha224": 5,
}

func (x RSAOAEPParm_Mask) String() string {
	return proto.EnumName(RSAOAEPParm_Mask_name, int32(x))
}

func (RSAOAEPParm_Mask) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{79, 0}
}

type RSAOAEPParm_ParmType int32

const (
	RSAOAEPParm_CkzNoDataSpecified RSAOAEPParm_ParmType = 0
	RSAOAEPParm_CkzDataSpecifiied  RSAOAEPParm_ParmType = 1
)

var RSAOAEPParm_ParmType_name = map[int32]string{
	0: "CkzNoDataSpecified",
	1: "CkzDataSpecifiied",
}

var RSAOAEPParm_ParmType_value = map[string]int32{
	"CkzNoDataSpecified": 0,
	"CkzDataSpecifiied":  1,
}

func (x RSAOAEPParm_ParmType) String() string {
	return proto.EnumName(RSAOAEPParm_ParmType_name, int32(x))
}

func (RSAOAEPParm_ParmType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{79, 1}
}

type RSAPSSParm_Mask int32

const (
	RSAPSSParm_CkgMgf1None   RSAPSSParm_Mask = 0
	RSAPSSParm_CkgMgf1Sha1   RSAPSSParm_Mask = 1
	RSAPSSParm_CkgMgf1Sha256 RSAPSSParm_Mask = 2
	RSAPSSParm_CkgMgf1Sha384 RSAPSSParm_Mask = 3
	RSAPSSParm_CkgMgf1Sha512 RSAPSSParm_Mask = 4
	RSAPSSParm_CkgMgf1Sha224 RSAPSSParm_Mask = 5
)

var RSAPSSParm_Mask_name = map[int32]string{
	0: "CkgMgf1None",
	1: "CkgMgf1Sha1",
	2: "CkgMgf1Sha256",
	3: "CkgMgf1Sha384",
	4: "CkgMgf1Sha512",
	5: "CkgMgf1Sha224",
}

var RSAPSSParm_Mask_value = map[string]int32{
	"CkgMgf1None":   0,
	"CkgMgf1Sha1":   1,
	"CkgMgf1Sha256": 2,
	"CkgMgf1Sha384": 3,
	"CkgMgf1Sha512": 4,
	"CkgMgf1Sha224": 5,
}

func (x RSAPSSParm_Mask) String() string {
	return proto.EnumName(RSAPSSParm_Mask_name, int32(x))
}

func (RSAPSSParm_Mask) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{80, 0}
}

type ECDH1DeriveParm_KeyDerivationFunction int32

const (
	ECDH1DeriveParm_CkdNotUsed0  ECDH1DeriveParm_KeyDerivationFunction = 0
	ECDH1DeriveParm_CkdNull      ECDH1DeriveParm_KeyDerivationFunction = 1
	ECDH1DeriveParm_CkdSha1Kdf   ECDH1DeriveParm_KeyDerivationFunction = 2
	ECDH1DeriveParm_CkdNotUsed3  ECDH1DeriveParm_KeyDerivationFunction = 3
	ECDH1DeriveParm_CkdNotUsed4  ECDH1DeriveParm_KeyDerivationFunction = 4
	ECDH1DeriveParm_CkdSha224Kdf ECDH1DeriveParm_KeyDerivationFunction = 5
	ECDH1DeriveParm_CkdSha256Kdf ECDH1DeriveParm_KeyDerivationFunction = 6
	ECDH1DeriveParm_CkdSha384Kdf ECDH1DeriveParm_KeyDerivationFunction = 7
	ECDH1DeriveParm_CkdSha512Kdf ECDH1DeriveParm_KeyDerivationFunction = 8
)

var ECDH1DeriveParm_KeyDerivationFunction_name = map[int32]string{
	0: "CkdNotUsed0",
	1: "CkdNull",
	2: "CkdSha1Kdf",
	3: "CkdNotUsed3",
	4: "CkdNotUsed4",
	5: "CkdSha224Kdf",
	6: "CkdSha256Kdf",
	7: "CkdSha384Kdf",
	8: "CkdSha512Kdf",
}

var ECDH1DeriveParm_KeyDerivationFunction_value = map[string]int32{
	"CkdNotUsed0":  0,
	"CkdNull":      1,
	"CkdSha1Kdf":   2,
	"CkdNotUsed3":  3,
	"CkdNotUsed4":  4,
	"CkdSha224Kdf": 5,
	"CkdSha256Kdf": 6,
	"CkdSha384Kdf": 7,
	"CkdSha512Kdf": 8,
}

func (x ECDH1DeriveParm_KeyDerivationFunction) String() string {
	return proto.EnumName(ECDH1DeriveParm_KeyDerivationFunction_name, int32(x))
}

func (ECDH1DeriveParm_KeyDerivationFunction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{81, 0}
}

type GenerateRandomRequest struct {
	Len                  uint64   `protobuf:"varint,1,opt,name=Len,proto3" json:"Len,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GenerateRandomRequest) Reset()         { *m = GenerateRandomRequest{} }
func (m *GenerateRandomRequest) String() string { return proto.CompactTextString(m) }
func (*GenerateRandomRequest) ProtoMessage()    {}
func (*GenerateRandomRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{0}
}
func (m *GenerateRandomRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenerateRandomRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenerateRandomRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenerateRandomRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenerateRandomRequest.Merge(m, src)
}
func (m *GenerateRandomRequest) XXX_Size() int {
	return m.Size()
}
func (m *GenerateRandomRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GenerateRandomRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GenerateRandomRequest proto.InternalMessageInfo

func (m *GenerateRandomRequest) GetLen() uint64 {
	if m != nil {
		return m.Len
	}
	return 0
}

type GenerateRandomResponse struct {
	Rnd                  []byte   `protobuf:"bytes,1,opt,name=Rnd,proto3" json:"Rnd,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GenerateRandomResponse) Reset()         { *m = GenerateRandomResponse{} }
func (m *GenerateRandomResponse) String() string { return proto.CompactTextString(m) }
func (*GenerateRandomResponse) ProtoMessage()    {}
func (*GenerateRandomResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{1}
}
func (m *GenerateRandomResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenerateRandomResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenerateRandomResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenerateRandomResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenerateRandomResponse.Merge(m, src)
}
func (m *GenerateRandomResponse) XXX_Size() int {
	return m.Size()
}
func (m *GenerateRandomResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GenerateRandomResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GenerateRandomResponse proto.InternalMessageInfo

func (m *GenerateRandomResponse) GetRnd() []byte {
	if m != nil {
		return m.Rnd
	}
	return nil
}

type DigestInitRequest struct {
	Mech                 *Mechanism `protobuf:"bytes,2,opt,name=Mech,proto3" json:"Mech,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *DigestInitRequest) Reset()         { *m = DigestInitRequest{} }
func (m *DigestInitRequest) String() string { return proto.CompactTextString(m) }
func (*DigestInitRequest) ProtoMessage()    {}
func (*DigestInitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{2}
}
func (m *DigestInitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DigestInitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DigestInitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DigestInitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DigestInitRequest.Merge(m, src)
}
func (m *DigestInitRequest) XXX_Size() int {
	return m.Size()
}
func (m *DigestInitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DigestInitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DigestInitRequest proto.InternalMessageInfo

func (m *DigestInitRequest) GetMech() *Mechanism {
	if m != nil {
		return m.Mech
	}
	return nil
}

type DigestInitResponse struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DigestInitResponse) Reset()         { *m = DigestInitResponse{} }
func (m *DigestInitResponse) String() string { return proto.CompactTextString(m) }
func (*DigestInitResponse) ProtoMessage()    {}
func (*DigestInitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{3}
}
func (m *DigestInitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DigestInitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DigestInitResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DigestInitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DigestInitResponse.Merge(m, src)
}
func (m *DigestInitResponse) XXX_Size() int {
	return m.Size()
}
func (m *DigestInitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DigestInitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DigestInitResponse proto.InternalMessageInfo

func (m *DigestInitResponse) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

type DigestRequest struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	Data                 []byte   `protobuf:"bytes,2,opt,name=Data,proto3" json:"Data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DigestRequest) Reset()         { *m = DigestRequest{} }
func (m *DigestRequest) String() string { return proto.CompactTextString(m) }
func (*DigestRequest) ProtoMessage()    {}
func (*DigestRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{4}
}
func (m *DigestRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DigestRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DigestRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DigestRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DigestRequest.Merge(m, src)
}
func (m *DigestRequest) XXX_Size() int {
	return m.Size()
}
func (m *DigestRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DigestRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DigestRequest proto.InternalMessageInfo

func (m *DigestRequest) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *DigestRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type DigestResponse struct {
	Digest               []byte   `protobuf:"bytes,3,opt,name=Digest,proto3" json:"Digest,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DigestResponse) Reset()         { *m = DigestResponse{} }
func (m *DigestResponse) String() string { return proto.CompactTextString(m) }
func (*DigestResponse) ProtoMessage()    {}
func (*DigestResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{5}
}
func (m *DigestResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DigestResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DigestResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DigestResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DigestResponse.Merge(m, src)
}
func (m *DigestResponse) XXX_Size() int {
	return m.Size()
}
func (m *DigestResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DigestResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DigestResponse proto.InternalMessageInfo

func (m *DigestResponse) GetDigest() []byte {
	if m != nil {
		return m.Digest
	}
	return nil
}

type DigestUpdateRequest struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	Data                 []byte   `protobuf:"bytes,2,opt,name=Data,proto3" json:"Data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DigestUpdateRequest) Reset()         { *m = DigestUpdateRequest{} }
func (m *DigestUpdateRequest) String() string { return proto.CompactTextString(m) }
func (*DigestUpdateRequest) ProtoMessage()    {}
func (*DigestUpdateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{6}
}
func (m *DigestUpdateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DigestUpdateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DigestUpdateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DigestUpdateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DigestUpdateRequest.Merge(m, src)
}
func (m *DigestUpdateRequest) XXX_Size() int {
	return m.Size()
}
func (m *DigestUpdateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DigestUpdateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DigestUpdateRequest proto.InternalMessageInfo

func (m *DigestUpdateRequest) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *DigestUpdateRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type DigestUpdateResponse struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DigestUpdateResponse) Reset()         { *m = DigestUpdateResponse{} }
func (m *DigestUpdateResponse) String() string { return proto.CompactTextString(m) }
func (*DigestUpdateResponse) ProtoMessage()    {}
func (*DigestUpdateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{7}
}
func (m *DigestUpdateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DigestUpdateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DigestUpdateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DigestUpdateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DigestUpdateResponse.Merge(m, src)
}
func (m *DigestUpdateResponse) XXX_Size() int {
	return m.Size()
}
func (m *DigestUpdateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DigestUpdateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DigestUpdateResponse proto.InternalMessageInfo

func (m *DigestUpdateResponse) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

type DigestKeyRequest struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	Key                  []byte   `protobuf:"bytes,2,opt,name=Key,proto3" json:"Key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DigestKeyRequest) Reset()         { *m = DigestKeyRequest{} }
func (m *DigestKeyRequest) String() string { return proto.CompactTextString(m) }
func (*DigestKeyRequest) ProtoMessage()    {}
func (*DigestKeyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{8}
}
func (m *DigestKeyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DigestKeyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DigestKeyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DigestKeyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DigestKeyRequest.Merge(m, src)
}
func (m *DigestKeyRequest) XXX_Size() int {
	return m.Size()
}
func (m *DigestKeyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DigestKeyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DigestKeyRequest proto.InternalMessageInfo

func (m *DigestKeyRequest) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *DigestKeyRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type DigestKeyResponse struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DigestKeyResponse) Reset()         { *m = DigestKeyResponse{} }
func (m *DigestKeyResponse) String() string { return proto.CompactTextString(m) }
func (*DigestKeyResponse) ProtoMessage()    {}
func (*DigestKeyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{9}
}
func (m *DigestKeyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DigestKeyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DigestKeyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DigestKeyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DigestKeyResponse.Merge(m, src)
}
func (m *DigestKeyResponse) XXX_Size() int {
	return m.Size()
}
func (m *DigestKeyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DigestKeyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DigestKeyResponse proto.InternalMessageInfo

func (m *DigestKeyResponse) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

type DigestFinalRequest struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DigestFinalRequest) Reset()         { *m = DigestFinalRequest{} }
func (m *DigestFinalRequest) String() string { return proto.CompactTextString(m) }
func (*DigestFinalRequest) ProtoMessage()    {}
func (*DigestFinalRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{10}
}
func (m *DigestFinalRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DigestFinalRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DigestFinalRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DigestFinalRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DigestFinalRequest.Merge(m, src)
}
func (m *DigestFinalRequest) XXX_Size() int {
	return m.Size()
}
func (m *DigestFinalRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DigestFinalRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DigestFinalRequest proto.InternalMessageInfo

func (m *DigestFinalRequest) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

type DigestFinalResponse struct {
	Digest               []byte   `protobuf:"bytes,2,opt,name=Digest,proto3" json:"Digest,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DigestFinalResponse) Reset()         { *m = DigestFinalResponse{} }
func (m *DigestFinalResponse) String() string { return proto.CompactTextString(m) }
func (*DigestFinalResponse) ProtoMessage()    {}
func (*DigestFinalResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{11}
}
func (m *DigestFinalResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DigestFinalResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DigestFinalResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DigestFinalResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DigestFinalResponse.Merge(m, src)
}
func (m *DigestFinalResponse) XXX_Size() int {
	return m.Size()
}
func (m *DigestFinalResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DigestFinalResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DigestFinalResponse proto.InternalMessageInfo

func (m *DigestFinalResponse) GetDigest() []byte {
	if m != nil {
		return m.Digest
	}
	return nil
}

type DigestSingleRequest struct {
	Mech                 *Mechanism `protobuf:"bytes,1,opt,name=Mech,proto3" json:"Mech,omitempty"`
	Data                 []byte     `protobuf:"bytes,2,opt,name=Data,proto3" json:"Data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *DigestSingleRequest) Reset()         { *m = DigestSingleRequest{} }
func (m *DigestSingleRequest) String() string { return proto.CompactTextString(m) }
func (*DigestSingleRequest) ProtoMessage()    {}
func (*DigestSingleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{12}
}
func (m *DigestSingleRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DigestSingleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DigestSingleRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DigestSingleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DigestSingleRequest.Merge(m, src)
}
func (m *DigestSingleRequest) XXX_Size() int {
	return m.Size()
}
func (m *DigestSingleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DigestSingleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DigestSingleRequest proto.InternalMessageInfo

func (m *DigestSingleRequest) GetMech() *Mechanism {
	if m != nil {
		return m.Mech
	}
	return nil
}

func (m *DigestSingleRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type DigestSingleResponse struct {
	Digest               []byte   `protobuf:"bytes,3,opt,name=Digest,proto3" json:"Digest,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DigestSingleResponse) Reset()         { *m = DigestSingleResponse{} }
func (m *DigestSingleResponse) String() string { return proto.CompactTextString(m) }
func (*DigestSingleResponse) ProtoMessage()    {}
func (*DigestSingleResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{13}
}
func (m *DigestSingleResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DigestSingleResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DigestSingleResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DigestSingleResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DigestSingleResponse.Merge(m, src)
}
func (m *DigestSingleResponse) XXX_Size() int {
	return m.Size()
}
func (m *DigestSingleResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DigestSingleResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DigestSingleResponse proto.InternalMessageInfo

func (m *DigestSingleResponse) GetDigest() []byte {
	if m != nil {
		return m.Digest
	}
	return nil
}

type EncryptInitRequest struct {
	Mech                 *Mechanism `protobuf:"bytes,2,opt,name=Mech,proto3" json:"Mech,omitempty"`
	Key                  []byte     `protobuf:"bytes,3,opt,name=Key,proto3" json:"Key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *EncryptInitRequest) Reset()         { *m = EncryptInitRequest{} }
func (m *EncryptInitRequest) String() string { return proto.CompactTextString(m) }
func (*EncryptInitRequest) ProtoMessage()    {}
func (*EncryptInitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{14}
}
func (m *EncryptInitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptInitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptInitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptInitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptInitRequest.Merge(m, src)
}
func (m *EncryptInitRequest) XXX_Size() int {
	return m.Size()
}
func (m *EncryptInitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptInitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptInitRequest proto.InternalMessageInfo

func (m *EncryptInitRequest) GetMech() *Mechanism {
	if m != nil {
		return m.Mech
	}
	return nil
}

func (m *EncryptInitRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type EncryptInitResponse struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EncryptInitResponse) Reset()         { *m = EncryptInitResponse{} }
func (m *EncryptInitResponse) String() string { return proto.CompactTextString(m) }
func (*EncryptInitResponse) ProtoMessage()    {}
func (*EncryptInitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{15}
}
func (m *EncryptInitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptInitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptInitResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptInitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptInitResponse.Merge(m, src)
}
func (m *EncryptInitResponse) XXX_Size() int {
	return m.Size()
}
func (m *EncryptInitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptInitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptInitResponse proto.InternalMessageInfo

func (m *EncryptInitResponse) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

type DecryptInitRequest struct {
	Mech                 *Mechanism `protobuf:"bytes,2,opt,name=Mech,proto3" json:"Mech,omitempty"`
	Key                  []byte     `protobuf:"bytes,3,opt,name=Key,proto3" json:"Key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *DecryptInitRequest) Reset()         { *m = DecryptInitRequest{} }
func (m *DecryptInitRequest) String() string { return proto.CompactTextString(m) }
func (*DecryptInitRequest) ProtoMessage()    {}
func (*DecryptInitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{16}
}
func (m *DecryptInitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DecryptInitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DecryptInitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DecryptInitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecryptInitRequest.Merge(m, src)
}
func (m *DecryptInitRequest) XXX_Size() int {
	return m.Size()
}
func (m *DecryptInitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DecryptInitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DecryptInitRequest proto.InternalMessageInfo

func (m *DecryptInitRequest) GetMech() *Mechanism {
	if m != nil {
		return m.Mech
	}
	return nil
}

func (m *DecryptInitRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type DecryptInitResponse struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DecryptInitResponse) Reset()         { *m = DecryptInitResponse{} }
func (m *DecryptInitResponse) String() string { return proto.CompactTextString(m) }
func (*DecryptInitResponse) ProtoMessage()    {}
func (*DecryptInitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{17}
}
func (m *DecryptInitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DecryptInitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DecryptInitResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DecryptInitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecryptInitResponse.Merge(m, src)
}
func (m *DecryptInitResponse) XXX_Size() int {
	return m.Size()
}
func (m *DecryptInitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DecryptInitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DecryptInitResponse proto.InternalMessageInfo

func (m *DecryptInitResponse) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

type EncryptUpdateRequest struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	Plain                []byte   `protobuf:"bytes,2,opt,name=Plain,proto3" json:"Plain,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EncryptUpdateRequest) Reset()         { *m = EncryptUpdateRequest{} }
func (m *EncryptUpdateRequest) String() string { return proto.CompactTextString(m) }
func (*EncryptUpdateRequest) ProtoMessage()    {}
func (*EncryptUpdateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{18}
}
func (m *EncryptUpdateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptUpdateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptUpdateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptUpdateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptUpdateRequest.Merge(m, src)
}
func (m *EncryptUpdateRequest) XXX_Size() int {
	return m.Size()
}
func (m *EncryptUpdateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptUpdateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptUpdateRequest proto.InternalMessageInfo

func (m *EncryptUpdateRequest) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *EncryptUpdateRequest) GetPlain() []byte {
	if m != nil {
		return m.Plain
	}
	return nil
}

type EncryptUpdateResponse struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	Ciphered             []byte   `protobuf:"bytes,3,opt,name=Ciphered,proto3" json:"Ciphered,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EncryptUpdateResponse) Reset()         { *m = EncryptUpdateResponse{} }
func (m *EncryptUpdateResponse) String() string { return proto.CompactTextString(m) }
func (*EncryptUpdateResponse) ProtoMessage()    {}
func (*EncryptUpdateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{19}
}
func (m *EncryptUpdateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptUpdateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptUpdateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptUpdateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptUpdateResponse.Merge(m, src)
}
func (m *EncryptUpdateResponse) XXX_Size() int {
	return m.Size()
}
func (m *EncryptUpdateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptUpdateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptUpdateResponse proto.InternalMessageInfo

func (m *EncryptUpdateResponse) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *EncryptUpdateResponse) GetCiphered() []byte {
	if m != nil {
		return m.Ciphered
	}
	return nil
}

type DecryptUpdateRequest struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	Ciphered             []byte   `protobuf:"bytes,2,opt,name=Ciphered,proto3" json:"Ciphered,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DecryptUpdateRequest) Reset()         { *m = DecryptUpdateRequest{} }
func (m *DecryptUpdateRequest) String() string { return proto.CompactTextString(m) }
func (*DecryptUpdateRequest) ProtoMessage()    {}
func (*DecryptUpdateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{20}
}
func (m *DecryptUpdateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DecryptUpdateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DecryptUpdateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DecryptUpdateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecryptUpdateRequest.Merge(m, src)
}
func (m *DecryptUpdateRequest) XXX_Size() int {
	return m.Size()
}
func (m *DecryptUpdateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DecryptUpdateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DecryptUpdateRequest proto.InternalMessageInfo

func (m *DecryptUpdateRequest) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *DecryptUpdateRequest) GetCiphered() []byte {
	if m != nil {
		return m.Ciphered
	}
	return nil
}

type DecryptUpdateResponse struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	Plain                []byte   `protobuf:"bytes,3,opt,name=Plain,proto3" json:"Plain,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DecryptUpdateResponse) Reset()         { *m = DecryptUpdateResponse{} }
func (m *DecryptUpdateResponse) String() string { return proto.CompactTextString(m) }
func (*DecryptUpdateResponse) ProtoMessage()    {}
func (*DecryptUpdateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{21}
}
func (m *DecryptUpdateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DecryptUpdateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DecryptUpdateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DecryptUpdateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecryptUpdateResponse.Merge(m, src)
}
func (m *DecryptUpdateResponse) XXX_Size() int {
	return m.Size()
}
func (m *DecryptUpdateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DecryptUpdateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DecryptUpdateResponse proto.InternalMessageInfo

func (m *DecryptUpdateResponse) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *DecryptUpdateResponse) GetPlain() []byte {
	if m != nil {
		return m.Plain
	}
	return nil
}

type EncryptRequest struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	Plain                []byte   `protobuf:"bytes,2,opt,name=Plain,proto3" json:"Plain,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EncryptRequest) Reset()         { *m = EncryptRequest{} }
func (m *EncryptRequest) String() string { return proto.CompactTextString(m) }
func (*EncryptRequest) ProtoMessage()    {}
func (*EncryptRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{22}
}
func (m *EncryptRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptRequest.Merge(m, src)
}
func (m *EncryptRequest) XXX_Size() int {
	return m.Size()
}
func (m *EncryptRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptRequest proto.InternalMessageInfo

func (m *EncryptRequest) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *EncryptRequest) GetPlain() []byte {
	if m != nil {
		return m.Plain
	}
	return nil
}

type EncryptResponse struct {
	Ciphered             []byte   `protobuf:"bytes,3,opt,name=Ciphered,proto3" json:"Ciphered,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EncryptResponse) Reset()         { *m = EncryptResponse{} }
func (m *EncryptResponse) String() string { return proto.CompactTextString(m) }
func (*EncryptResponse) ProtoMessage()    {}
func (*EncryptResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{23}
}
func (m *EncryptResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptResponse.Merge(m, src)
}
func (m *EncryptResponse) XXX_Size() int {
	return m.Size()
}
func (m *EncryptResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptResponse proto.InternalMessageInfo

func (m *EncryptResponse) GetCiphered() []byte {
	if m != nil {
		return m.Ciphered
	}
	return nil
}

type DecryptRequest struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	Ciphered             []byte   `protobuf:"bytes,2,opt,name=Ciphered,proto3" json:"Ciphered,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DecryptRequest) Reset()         { *m = DecryptRequest{} }
func (m *DecryptRequest) String() string { return proto.CompactTextString(m) }
func (*DecryptRequest) ProtoMessage()    {}
func (*DecryptRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{24}
}
func (m *DecryptRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DecryptRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DecryptRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DecryptRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecryptRequest.Merge(m, src)
}
func (m *DecryptRequest) XXX_Size() int {
	return m.Size()
}
func (m *DecryptRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DecryptRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DecryptRequest proto.InternalMessageInfo

func (m *DecryptRequest) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *DecryptRequest) GetCiphered() []byte {
	if m != nil {
		return m.Ciphered
	}
	return nil
}

type DecryptResponse struct {
	Plain                []byte   `protobuf:"bytes,3,opt,name=Plain,proto3" json:"Plain,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DecryptResponse) Reset()         { *m = DecryptResponse{} }
func (m *DecryptResponse) String() string { return proto.CompactTextString(m) }
func (*DecryptResponse) ProtoMessage()    {}
func (*DecryptResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{25}
}
func (m *DecryptResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DecryptResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DecryptResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DecryptResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecryptResponse.Merge(m, src)
}
func (m *DecryptResponse) XXX_Size() int {
	return m.Size()
}
func (m *DecryptResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DecryptResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DecryptResponse proto.InternalMessageInfo

func (m *DecryptResponse) GetPlain() []byte {
	if m != nil {
		return m.Plain
	}
	return nil
}

type EncryptFinalRequest struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EncryptFinalRequest) Reset()         { *m = EncryptFinalRequest{} }
func (m *EncryptFinalRequest) String() string { return proto.CompactTextString(m) }
func (*EncryptFinalRequest) ProtoMessage()    {}
func (*EncryptFinalRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{26}
}
func (m *EncryptFinalRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptFinalRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptFinalRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptFinalRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptFinalRequest.Merge(m, src)
}
func (m *EncryptFinalRequest) XXX_Size() int {
	return m.Size()
}
func (m *EncryptFinalRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptFinalRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptFinalRequest proto.InternalMessageInfo

func (m *EncryptFinalRequest) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

type EncryptFinalResponse struct {
	Ciphered             []byte   `protobuf:"bytes,2,opt,name=Ciphered,proto3" json:"Ciphered,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EncryptFinalResponse) Reset()         { *m = EncryptFinalResponse{} }
func (m *EncryptFinalResponse) String() string { return proto.CompactTextString(m) }
func (*EncryptFinalResponse) ProtoMessage()    {}
func (*EncryptFinalResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{27}
}
func (m *EncryptFinalResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptFinalResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptFinalResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptFinalResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptFinalResponse.Merge(m, src)
}
func (m *EncryptFinalResponse) XXX_Size() int {
	return m.Size()
}
func (m *EncryptFinalResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptFinalResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptFinalResponse proto.InternalMessageInfo

func (m *EncryptFinalResponse) GetCiphered() []byte {
	if m != nil {
		return m.Ciphered
	}
	return nil
}

type DecryptFinalRequest struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DecryptFinalRequest) Reset()         { *m = DecryptFinalRequest{} }
func (m *DecryptFinalRequest) String() string { return proto.CompactTextString(m) }
func (*DecryptFinalRequest) ProtoMessage()    {}
func (*DecryptFinalRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{28}
}
func (m *DecryptFinalRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DecryptFinalRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DecryptFinalRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DecryptFinalRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecryptFinalRequest.Merge(m, src)
}
func (m *DecryptFinalRequest) XXX_Size() int {
	return m.Size()
}
func (m *DecryptFinalRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DecryptFinalRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DecryptFinalRequest proto.InternalMessageInfo

func (m *DecryptFinalRequest) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

type DecryptFinalResponse struct {
	Plain                []byte   `protobuf:"bytes,2,opt,name=Plain,proto3" json:"Plain,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DecryptFinalResponse) Reset()         { *m = DecryptFinalResponse{} }
func (m *DecryptFinalResponse) String() string { return proto.CompactTextString(m) }
func (*DecryptFinalResponse) ProtoMessage()    {}
func (*DecryptFinalResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{29}
}
func (m *DecryptFinalResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DecryptFinalResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DecryptFinalResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DecryptFinalResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecryptFinalResponse.Merge(m, src)
}
func (m *DecryptFinalResponse) XXX_Size() int {
	return m.Size()
}
func (m *DecryptFinalResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DecryptFinalResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DecryptFinalResponse proto.InternalMessageInfo

func (m *DecryptFinalResponse) GetPlain() []byte {
	if m != nil {
		return m.Plain
	}
	return nil
}

type EncryptSingleRequest struct {
	Key                  []byte     `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	Mech                 *Mechanism `protobuf:"bytes,2,opt,name=Mech,proto3" json:"Mech,omitempty"`
	Plain                []byte     `protobuf:"bytes,3,opt,name=Plain,proto3" json:"Plain,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *EncryptSingleRequest) Reset()         { *m = EncryptSingleRequest{} }
func (m *EncryptSingleRequest) String() string { return proto.CompactTextString(m) }
func (*EncryptSingleRequest) ProtoMessage()    {}
func (*EncryptSingleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{30}
}
func (m *EncryptSingleRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptSingleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptSingleRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptSingleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptSingleRequest.Merge(m, src)
}
func (m *EncryptSingleRequest) XXX_Size() int {
	return m.Size()
}
func (m *EncryptSingleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptSingleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptSingleRequest proto.InternalMessageInfo

func (m *EncryptSingleRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *EncryptSingleRequest) GetMech() *Mechanism {
	if m != nil {
		return m.Mech
	}
	return nil
}

func (m *EncryptSingleRequest) GetPlain() []byte {
	if m != nil {
		return m.Plain
	}
	return nil
}

type EncryptSingleResponse struct {
	Ciphered             []byte   `protobuf:"bytes,4,opt,name=Ciphered,proto3" json:"Ciphered,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EncryptSingleResponse) Reset()         { *m = EncryptSingleResponse{} }
func (m *EncryptSingleResponse) String() string { return proto.CompactTextString(m) }
func (*EncryptSingleResponse) ProtoMessage()    {}
func (*EncryptSingleResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{31}
}
func (m *EncryptSingleResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptSingleResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptSingleResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptSingleResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptSingleResponse.Merge(m, src)
}
func (m *EncryptSingleResponse) XXX_Size() int {
	return m.Size()
}
func (m *EncryptSingleResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptSingleResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptSingleResponse proto.InternalMessageInfo

func (m *EncryptSingleResponse) GetCiphered() []byte {
	if m != nil {
		return m.Ciphered
	}
	return nil
}

type DecryptSingleRequest struct {
	Key                  []byte     `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	Mech                 *Mechanism `protobuf:"bytes,2,opt,name=Mech,proto3" json:"Mech,omitempty"`
	Ciphered             []byte     `protobuf:"bytes,3,opt,name=Ciphered,proto3" json:"Ciphered,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *DecryptSingleRequest) Reset()         { *m = DecryptSingleRequest{} }
func (m *DecryptSingleRequest) String() string { return proto.CompactTextString(m) }
func (*DecryptSingleRequest) ProtoMessage()    {}
func (*DecryptSingleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{32}
}
func (m *DecryptSingleRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DecryptSingleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DecryptSingleRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DecryptSingleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecryptSingleRequest.Merge(m, src)
}
func (m *DecryptSingleRequest) XXX_Size() int {
	return m.Size()
}
func (m *DecryptSingleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DecryptSingleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DecryptSingleRequest proto.InternalMessageInfo

func (m *DecryptSingleRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *DecryptSingleRequest) GetMech() *Mechanism {
	if m != nil {
		return m.Mech
	}
	return nil
}

func (m *DecryptSingleRequest) GetCiphered() []byte {
	if m != nil {
		return m.Ciphered
	}
	return nil
}

type DecryptSingleResponse struct {
	Plain                []byte   `protobuf:"bytes,4,opt,name=Plain,proto3" json:"Plain,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DecryptSingleResponse) Reset()         { *m = DecryptSingleResponse{} }
func (m *DecryptSingleResponse) String() string { return proto.CompactTextString(m) }
func (*DecryptSingleResponse) ProtoMessage()    {}
func (*DecryptSingleResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{33}
}
func (m *DecryptSingleResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DecryptSingleResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DecryptSingleResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DecryptSingleResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecryptSingleResponse.Merge(m, src)
}
func (m *DecryptSingleResponse) XXX_Size() int {
	return m.Size()
}
func (m *DecryptSingleResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DecryptSingleResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DecryptSingleResponse proto.InternalMessageInfo

func (m *DecryptSingleResponse) GetPlain() []byte {
	if m != nil {
		return m.Plain
	}
	return nil
}

type SignInitRequest struct {
	Mech                 *Mechanism `protobuf:"bytes,2,opt,name=Mech,proto3" json:"Mech,omitempty"`
	PrivKey              []byte     `protobuf:"bytes,3,opt,name=PrivKey,proto3" json:"PrivKey,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *SignInitRequest) Reset()         { *m = SignInitRequest{} }
func (m *SignInitRequest) String() string { return proto.CompactTextString(m) }
func (*SignInitRequest) ProtoMessage()    {}
func (*SignInitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{34}
}
func (m *SignInitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignInitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignInitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignInitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignInitRequest.Merge(m, src)
}
func (m *SignInitRequest) XXX_Size() int {
	return m.Size()
}
func (m *SignInitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SignInitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SignInitRequest proto.InternalMessageInfo

func (m *SignInitRequest) GetMech() *Mechanism {
	if m != nil {
		return m.Mech
	}
	return nil
}

func (m *SignInitRequest) GetPrivKey() []byte {
	if m != nil {
		return m.PrivKey
	}
	return nil
}

type SignInitResponse struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SignInitResponse) Reset()         { *m = SignInitResponse{} }
func (m *SignInitResponse) String() string { return proto.CompactTextString(m) }
func (*SignInitResponse) ProtoMessage()    {}
func (*SignInitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{35}
}
func (m *SignInitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignInitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignInitResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignInitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignInitResponse.Merge(m, src)
}
func (m *SignInitResponse) XXX_Size() int {
	return m.Size()
}
func (m *SignInitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SignInitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SignInitResponse proto.InternalMessageInfo

func (m *SignInitResponse) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

type VerifyInitRequest struct {
	Mech                 *Mechanism `protobuf:"bytes,2,opt,name=Mech,proto3" json:"Mech,omitempty"`
	PubKey               []byte     `protobuf:"bytes,3,opt,name=PubKey,proto3" json:"PubKey,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *VerifyInitRequest) Reset()         { *m = VerifyInitRequest{} }
func (m *VerifyInitRequest) String() string { return proto.CompactTextString(m) }
func (*VerifyInitRequest) ProtoMessage()    {}
func (*VerifyInitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{36}
}
func (m *VerifyInitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyInitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyInitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerifyInitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyInitRequest.Merge(m, src)
}
func (m *VerifyInitRequest) XXX_Size() int {
	return m.Size()
}
func (m *VerifyInitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyInitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyInitRequest proto.InternalMessageInfo

func (m *VerifyInitRequest) GetMech() *Mechanism {
	if m != nil {
		return m.Mech
	}
	return nil
}

func (m *VerifyInitRequest) GetPubKey() []byte {
	if m != nil {
		return m.PubKey
	}
	return nil
}

type VerifyInitResponse struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VerifyInitResponse) Reset()         { *m = VerifyInitResponse{} }
func (m *VerifyInitResponse) String() string { return proto.CompactTextString(m) }
func (*VerifyInitResponse) ProtoMessage()    {}
func (*VerifyInitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{37}
}
func (m *VerifyInitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyInitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyInitResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerifyInitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyInitResponse.Merge(m, src)
}
func (m *VerifyInitResponse) XXX_Size() int {
	return m.Size()
}
func (m *VerifyInitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyInitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyInitResponse proto.InternalMessageInfo

func (m *VerifyInitResponse) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

type SignUpdateRequest struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	Data                 []byte   `protobuf:"bytes,2,opt,name=Data,proto3" json:"Data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SignUpdateRequest) Reset()         { *m = SignUpdateRequest{} }
func (m *SignUpdateRequest) String() string { return proto.CompactTextString(m) }
func (*SignUpdateRequest) ProtoMessage()    {}
func (*SignUpdateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{38}
}
func (m *SignUpdateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignUpdateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignUpdateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignUpdateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignUpdateRequest.Merge(m, src)
}
func (m *SignUpdateRequest) XXX_Size() int {
	return m.Size()
}
func (m *SignUpdateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SignUpdateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SignUpdateRequest proto.InternalMessageInfo

func (m *SignUpdateRequest) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *SignUpdateRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type SignUpdateResponse struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SignUpdateResponse) Reset()         { *m = SignUpdateResponse{} }
func (m *SignUpdateResponse) String() string { return proto.CompactTextString(m) }
func (*SignUpdateResponse) ProtoMessage()    {}
func (*SignUpdateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{39}
}
func (m *SignUpdateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignUpdateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignUpdateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignUpdateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignUpdateResponse.Merge(m, src)
}
func (m *SignUpdateResponse) XXX_Size() int {
	return m.Size()
}
func (m *SignUpdateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SignUpdateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SignUpdateResponse proto.InternalMessageInfo

func (m *SignUpdateResponse) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

type VerifyUpdateRequest struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	Data                 []byte   `protobuf:"bytes,2,opt,name=Data,proto3" json:"Data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VerifyUpdateRequest) Reset()         { *m = VerifyUpdateRequest{} }
func (m *VerifyUpdateRequest) String() string { return proto.CompactTextString(m) }
func (*VerifyUpdateRequest) ProtoMessage()    {}
func (*VerifyUpdateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{40}
}
func (m *VerifyUpdateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyUpdateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyUpdateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerifyUpdateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyUpdateRequest.Merge(m, src)
}
func (m *VerifyUpdateRequest) XXX_Size() int {
	return m.Size()
}
func (m *VerifyUpdateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyUpdateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyUpdateRequest proto.InternalMessageInfo

func (m *VerifyUpdateRequest) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *VerifyUpdateRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type VerifyUpdateResponse struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VerifyUpdateResponse) Reset()         { *m = VerifyUpdateResponse{} }
func (m *VerifyUpdateResponse) String() string { return proto.CompactTextString(m) }
func (*VerifyUpdateResponse) ProtoMessage()    {}
func (*VerifyUpdateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{41}
}
func (m *VerifyUpdateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyUpdateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyUpdateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerifyUpdateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyUpdateResponse.Merge(m, src)
}
func (m *VerifyUpdateResponse) XXX_Size() int {
	return m.Size()
}
func (m *VerifyUpdateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyUpdateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyUpdateResponse proto.InternalMessageInfo

func (m *VerifyUpdateResponse) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

type SignFinalRequest struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SignFinalRequest) Reset()         { *m = SignFinalRequest{} }
func (m *SignFinalRequest) String() string { return proto.CompactTextString(m) }
func (*SignFinalRequest) ProtoMessage()    {}
func (*SignFinalRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{42}
}
func (m *SignFinalRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignFinalRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignFinalRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignFinalRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignFinalRequest.Merge(m, src)
}
func (m *SignFinalRequest) XXX_Size() int {
	return m.Size()
}
func (m *SignFinalRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SignFinalRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SignFinalRequest proto.InternalMessageInfo

func (m *SignFinalRequest) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

type SignFinalResponse struct {
	Signature            []byte   `protobuf:"bytes,2,opt,name=Signature,proto3" json:"Signature,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SignFinalResponse) Reset()         { *m = SignFinalResponse{} }
func (m *SignFinalResponse) String() string { return proto.CompactTextString(m) }
func (*SignFinalResponse) ProtoMessage()    {}
func (*SignFinalResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{43}
}
func (m *SignFinalResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignFinalResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignFinalResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignFinalResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignFinalResponse.Merge(m, src)
}
func (m *SignFinalResponse) XXX_Size() int {
	return m.Size()
}
func (m *SignFinalResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SignFinalResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SignFinalResponse proto.InternalMessageInfo

func (m *SignFinalResponse) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

type VerifyFinalRequest struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	Signature            []byte   `protobuf:"bytes,2,opt,name=Signature,proto3" json:"Signature,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VerifyFinalRequest) Reset()         { *m = VerifyFinalRequest{} }
func (m *VerifyFinalRequest) String() string { return proto.CompactTextString(m) }
func (*VerifyFinalRequest) ProtoMessage()    {}
func (*VerifyFinalRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{44}
}
func (m *VerifyFinalRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyFinalRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyFinalRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerifyFinalRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyFinalRequest.Merge(m, src)
}
func (m *VerifyFinalRequest) XXX_Size() int {
	return m.Size()
}
func (m *VerifyFinalRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyFinalRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyFinalRequest proto.InternalMessageInfo

func (m *VerifyFinalRequest) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *VerifyFinalRequest) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

type VerifyFinalResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VerifyFinalResponse) Reset()         { *m = VerifyFinalResponse{} }
func (m *VerifyFinalResponse) String() string { return proto.CompactTextString(m) }
func (*VerifyFinalResponse) ProtoMessage()    {}
func (*VerifyFinalResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{45}
}
func (m *VerifyFinalResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyFinalResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyFinalResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerifyFinalResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyFinalResponse.Merge(m, src)
}
func (m *VerifyFinalResponse) XXX_Size() int {
	return m.Size()
}
func (m *VerifyFinalResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyFinalResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyFinalResponse proto.InternalMessageInfo

type SignRequest struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	Data                 []byte   `protobuf:"bytes,2,opt,name=Data,proto3" json:"Data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SignRequest) Reset()         { *m = SignRequest{} }
func (m *SignRequest) String() string { return proto.CompactTextString(m) }
func (*SignRequest) ProtoMessage()    {}
func (*SignRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{46}
}
func (m *SignRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignRequest.Merge(m, src)
}
func (m *SignRequest) XXX_Size() int {
	return m.Size()
}
func (m *SignRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SignRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SignRequest proto.InternalMessageInfo

func (m *SignRequest) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *SignRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type SignResponse struct {
	Signature            []byte   `protobuf:"bytes,3,opt,name=Signature,proto3" json:"Signature,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SignResponse) Reset()         { *m = SignResponse{} }
func (m *SignResponse) String() string { return proto.CompactTextString(m) }
func (*SignResponse) ProtoMessage()    {}
func (*SignResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{47}
}
func (m *SignResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignResponse.Merge(m, src)
}
func (m *SignResponse) XXX_Size() int {
	return m.Size()
}
func (m *SignResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SignResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SignResponse proto.InternalMessageInfo

func (m *SignResponse) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

type VerifyRequest struct {
	State                []byte   `protobuf:"bytes,1,opt,name=State,proto3" json:"State,omitempty"`
	Data                 []byte   `protobuf:"bytes,2,opt,name=Data,proto3" json:"Data,omitempty"`
	Signature            []byte   `protobuf:"bytes,3,opt,name=Signature,proto3" json:"Signature,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VerifyRequest) Reset()         { *m = VerifyRequest{} }
func (m *VerifyRequest) String() string { return proto.CompactTextString(m) }
func (*VerifyRequest) ProtoMessage()    {}
func (*VerifyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{48}
}
func (m *VerifyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerifyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyRequest.Merge(m, src)
}
func (m *VerifyRequest) XXX_Size() int {
	return m.Size()
}
func (m *VerifyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyRequest proto.InternalMessageInfo

func (m *VerifyRequest) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *VerifyRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *VerifyRequest) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

type VerifyResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VerifyResponse) Reset()         { *m = VerifyResponse{} }
func (m *VerifyResponse) String() string { return proto.CompactTextString(m) }
func (*VerifyResponse) ProtoMessage()    {}
func (*VerifyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{49}
}
func (m *VerifyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerifyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyResponse.Merge(m, src)
}
func (m *VerifyResponse) XXX_Size() int {
	return m.Size()
}
func (m *VerifyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyResponse proto.InternalMessageInfo

type SignSingleRequest struct {
	PrivKey              []byte     `protobuf:"bytes,1,opt,name=PrivKey,proto3" json:"PrivKey,omitempty"`
	Mech                 *Mechanism `protobuf:"bytes,2,opt,name=Mech,proto3" json:"Mech,omitempty"`
	Data                 []byte     `protobuf:"bytes,3,opt,name=Data,proto3" json:"Data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *SignSingleRequest) Reset()         { *m = SignSingleRequest{} }
func (m *SignSingleRequest) String() string { return proto.CompactTextString(m) }
func (*SignSingleRequest) ProtoMessage()    {}
func (*SignSingleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{50}
}
func (m *SignSingleRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignSingleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignSingleRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignSingleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignSingleRequest.Merge(m, src)
}
func (m *SignSingleRequest) XXX_Size() int {
	return m.Size()
}
func (m *SignSingleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SignSingleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SignSingleRequest proto.InternalMessageInfo

func (m *SignSingleRequest) GetPrivKey() []byte {
	if m != nil {
		return m.PrivKey
	}
	return nil
}

func (m *SignSingleRequest) GetMech() *Mechanism {
	if m != nil {
		return m.Mech
	}
	return nil
}

func (m *SignSingleRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type SignSingleResponse struct {
	Signature            []byte   `protobuf:"bytes,4,opt,name=Signature,proto3" json:"Signature,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SignSingleResponse) Reset()         { *m = SignSingleResponse{} }
func (m *SignSingleResponse) String() string { return proto.CompactTextString(m) }
func (*SignSingleResponse) ProtoMessage()    {}
func (*SignSingleResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{51}
}
func (m *SignSingleResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignSingleResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignSingleResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignSingleResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignSingleResponse.Merge(m, src)
}
func (m *SignSingleResponse) XXX_Size() int {
	return m.Size()
}
func (m *SignSingleResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SignSingleResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SignSingleResponse proto.InternalMessageInfo

func (m *SignSingleResponse) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

type VerifySingleRequest struct {
	PubKey               []byte     `protobuf:"bytes,1,opt,name=PubKey,proto3" json:"PubKey,omitempty"`
	Mech                 *Mechanism `protobuf:"bytes,2,opt,name=Mech,proto3" json:"Mech,omitempty"`
	Data                 []byte     `protobuf:"bytes,3,opt,name=Data,proto3" json:"Data,omitempty"`
	Signature            []byte     `protobuf:"bytes,4,opt,name=Signature,proto3" json:"Signature,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *VerifySingleRequest) Reset()         { *m = VerifySingleRequest{} }
func (m *VerifySingleRequest) String() string { return proto.CompactTextString(m) }
func (*VerifySingleRequest) ProtoMessage()    {}
func (*VerifySingleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{52}
}
func (m *VerifySingleRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifySingleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifySingleRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerifySingleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifySingleRequest.Merge(m, src)
}
func (m *VerifySingleRequest) XXX_Size() int {
	return m.Size()
}
func (m *VerifySingleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifySingleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VerifySingleRequest proto.InternalMessageInfo

func (m *VerifySingleRequest) GetPubKey() []byte {
	if m != nil {
		return m.PubKey
	}
	return nil
}

func (m *VerifySingleRequest) GetMech() *Mechanism {
	if m != nil {
		return m.Mech
	}
	return nil
}

func (m *VerifySingleRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *VerifySingleRequest) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

type VerifySingleResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VerifySingleResponse) Reset()         { *m = VerifySingleResponse{} }
func (m *VerifySingleResponse) String() string { return proto.CompactTextString(m) }
func (*VerifySingleResponse) ProtoMessage()    {}
func (*VerifySingleResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{53}
}
func (m *VerifySingleResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifySingleResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifySingleResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerifySingleResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifySingleResponse.Merge(m, src)
}
func (m *VerifySingleResponse) XXX_Size() int {
	return m.Size()
}
func (m *VerifySingleResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifySingleResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VerifySingleResponse proto.InternalMessageInfo

type GenerateKeyRequest struct {
	Mech                 *Mechanism                                                             `protobuf:"bytes,1,opt,name=Mech,proto3" json:"Mech,omitempty"`
	Template             map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute]*AttributeValue `protobuf:"bytes,6,rep,name=Template,proto3,castkey=github.com/IBM-Cloud/hpcs-grep11-go/ep11.Attribute" json:"Template,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                                                               `json:"-"`
	XXX_unrecognized     []byte                                                                 `json:"-"`
	XXX_sizecache        int32                                                                  `json:"-"`
}

func (m *GenerateKeyRequest) Reset()         { *m = GenerateKeyRequest{} }
func (m *GenerateKeyRequest) String() string { return proto.CompactTextString(m) }
func (*GenerateKeyRequest) ProtoMessage()    {}
func (*GenerateKeyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{54}
}
func (m *GenerateKeyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenerateKeyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenerateKeyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenerateKeyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenerateKeyRequest.Merge(m, src)
}
func (m *GenerateKeyRequest) XXX_Size() int {
	return m.Size()
}
func (m *GenerateKeyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GenerateKeyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GenerateKeyRequest proto.InternalMessageInfo

func (m *GenerateKeyRequest) GetMech() *Mechanism {
	if m != nil {
		return m.Mech
	}
	return nil
}

func (m *GenerateKeyRequest) GetTemplate() map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute]*AttributeValue {
	if m != nil {
		return m.Template
	}
	return nil
}

type GenerateKeyResponse struct {
	KeyBytes             []byte   `protobuf:"bytes,4,opt,name=KeyBytes,proto3" json:"KeyBytes,omitempty"`
	CheckSum             []byte   `protobuf:"bytes,5,opt,name=CheckSum,proto3" json:"CheckSum,omitempty"`
	Key                  *KeyBlob `protobuf:"bytes,7,opt,name=Key,proto3" json:"Key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GenerateKeyResponse) Reset()         { *m = GenerateKeyResponse{} }
func (m *GenerateKeyResponse) String() string { return proto.CompactTextString(m) }
func (*GenerateKeyResponse) ProtoMessage()    {}
func (*GenerateKeyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{55}
}
func (m *GenerateKeyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenerateKeyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenerateKeyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenerateKeyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenerateKeyResponse.Merge(m, src)
}
func (m *GenerateKeyResponse) XXX_Size() int {
	return m.Size()
}
func (m *GenerateKeyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GenerateKeyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GenerateKeyResponse proto.InternalMessageInfo

func (m *GenerateKeyResponse) GetKeyBytes() []byte {
	if m != nil {
		return m.KeyBytes
	}
	return nil
}

func (m *GenerateKeyResponse) GetCheckSum() []byte {
	if m != nil {
		return m.CheckSum
	}
	return nil
}

func (m *GenerateKeyResponse) GetKey() *KeyBlob {
	if m != nil {
		return m.Key
	}
	return nil
}

type GenerateKeyPairRequest struct {
	Mech                 *Mechanism                                                             `protobuf:"bytes,1,opt,name=Mech,proto3" json:"Mech,omitempty"`
	PrivKeyTemplate      map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute]*AttributeValue `protobuf:"bytes,7,rep,name=PrivKeyTemplate,proto3,castkey=github.com/IBM-Cloud/hpcs-grep11-go/ep11.Attribute" json:"PrivKeyTemplate,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	PubKeyTemplate       map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute]*AttributeValue `protobuf:"bytes,8,rep,name=PubKeyTemplate,proto3,castkey=github.com/IBM-Cloud/hpcs-grep11-go/ep11.Attribute" json:"PubKeyTemplate,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                                                               `json:"-"`
	XXX_unrecognized     []byte                                                                 `json:"-"`
	XXX_sizecache        int32                                                                  `json:"-"`
}

func (m *GenerateKeyPairRequest) Reset()         { *m = GenerateKeyPairRequest{} }
func (m *GenerateKeyPairRequest) String() string { return proto.CompactTextString(m) }
func (*GenerateKeyPairRequest) ProtoMessage()    {}
func (*GenerateKeyPairRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{56}
}
func (m *GenerateKeyPairRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenerateKeyPairRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenerateKeyPairRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenerateKeyPairRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenerateKeyPairRequest.Merge(m, src)
}
func (m *GenerateKeyPairRequest) XXX_Size() int {
	return m.Size()
}
func (m *GenerateKeyPairRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GenerateKeyPairRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GenerateKeyPairRequest proto.InternalMessageInfo

func (m *GenerateKeyPairRequest) GetMech() *Mechanism {
	if m != nil {
		return m.Mech
	}
	return nil
}

func (m *GenerateKeyPairRequest) GetPrivKeyTemplate() map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute]*AttributeValue {
	if m != nil {
		return m.PrivKeyTemplate
	}
	return nil
}

func (m *GenerateKeyPairRequest) GetPubKeyTemplate() map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute]*AttributeValue {
	if m != nil {
		return m.PubKeyTemplate
	}
	return nil
}

type GenerateKeyPairResponse struct {
	PrivKeyBytes         []byte   `protobuf:"bytes,5,opt,name=PrivKeyBytes,proto3" json:"PrivKeyBytes,omitempty"`
	PubKeyBytes          []byte   `protobuf:"bytes,6,opt,name=PubKeyBytes,proto3" json:"PubKeyBytes,omitempty"`
	PrivKey              *KeyBlob `protobuf:"bytes,9,opt,name=PrivKey,proto3" json:"PrivKey,omitempty"`
	PubKey               *KeyBlob `protobuf:"bytes,10,opt,name=PubKey,proto3" json:"PubKey,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GenerateKeyPairResponse) Reset()         { *m = GenerateKeyPairResponse{} }
func (m *GenerateKeyPairResponse) String() string { return proto.CompactTextString(m) }
func (*GenerateKeyPairResponse) ProtoMessage()    {}
func (*GenerateKeyPairResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{57}
}
func (m *GenerateKeyPairResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenerateKeyPairResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenerateKeyPairResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenerateKeyPairResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenerateKeyPairResponse.Merge(m, src)
}
func (m *GenerateKeyPairResponse) XXX_Size() int {
	return m.Size()
}
func (m *GenerateKeyPairResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GenerateKeyPairResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GenerateKeyPairResponse proto.InternalMessageInfo

func (m *GenerateKeyPairResponse) GetPrivKeyBytes() []byte {
	if m != nil {
		return m.PrivKeyBytes
	}
	return nil
}

func (m *GenerateKeyPairResponse) GetPubKeyBytes() []byte {
	if m != nil {
		return m.PubKeyBytes
	}
	return nil
}

func (m *GenerateKeyPairResponse) GetPrivKey() *KeyBlob {
	if m != nil {
		return m.PrivKey
	}
	return nil
}

func (m *GenerateKeyPairResponse) GetPubKey() *KeyBlob {
	if m != nil {
		return m.PubKey
	}
	return nil
}

type WrapKeyRequest struct {
	Key                  []byte     `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	KeK                  []byte     `protobuf:"bytes,2,opt,name=KeK,proto3" json:"KeK,omitempty"`
	MacKey               []byte     `protobuf:"bytes,3,opt,name=MacKey,proto3" json:"MacKey,omitempty"`
	Mech                 *Mechanism `protobuf:"bytes,4,opt,name=Mech,proto3" json:"Mech,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *WrapKeyRequest) Reset()         { *m = WrapKeyRequest{} }
func (m *WrapKeyRequest) String() string { return proto.CompactTextString(m) }
func (*WrapKeyRequest) ProtoMessage()    {}
func (*WrapKeyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{58}
}
func (m *WrapKeyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WrapKeyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WrapKeyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WrapKeyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WrapKeyRequest.Merge(m, src)
}
func (m *WrapKeyRequest) XXX_Size() int {
	return m.Size()
}
func (m *WrapKeyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WrapKeyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WrapKeyRequest proto.InternalMessageInfo

func (m *WrapKeyRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *WrapKeyRequest) GetKeK() []byte {
	if m != nil {
		return m.KeK
	}
	return nil
}

func (m *WrapKeyRequest) GetMacKey() []byte {
	if m != nil {
		return m.MacKey
	}
	return nil
}

func (m *WrapKeyRequest) GetMech() *Mechanism {
	if m != nil {
		return m.Mech
	}
	return nil
}

type WrapKeyResponse struct {
	Wrapped              []byte   `protobuf:"bytes,5,opt,name=Wrapped,proto3" json:"Wrapped,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WrapKeyResponse) Reset()         { *m = WrapKeyResponse{} }
func (m *WrapKeyResponse) String() string { return proto.CompactTextString(m) }
func (*WrapKeyResponse) ProtoMessage()    {}
func (*WrapKeyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{59}
}
func (m *WrapKeyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WrapKeyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WrapKeyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WrapKeyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WrapKeyResponse.Merge(m, src)
}
func (m *WrapKeyResponse) XXX_Size() int {
	return m.Size()
}
func (m *WrapKeyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_WrapKeyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_WrapKeyResponse proto.InternalMessageInfo

func (m *WrapKeyResponse) GetWrapped() []byte {
	if m != nil {
		return m.Wrapped
	}
	return nil
}

type UnwrapKeyRequest struct {
	Wrapped              []byte                                                                 `protobuf:"bytes,1,opt,name=Wrapped,proto3" json:"Wrapped,omitempty"`
	KeK                  []byte                                                                 `protobuf:"bytes,2,opt,name=KeK,proto3" json:"KeK,omitempty"`
	MacKey               []byte                                                                 `protobuf:"bytes,3,opt,name=MacKey,proto3" json:"MacKey,omitempty"`
	Mech                 *Mechanism                                                             `protobuf:"bytes,5,opt,name=Mech,proto3" json:"Mech,omitempty"`
	Template             map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute]*AttributeValue `protobuf:"bytes,9,rep,name=Template,proto3,castkey=github.com/IBM-Cloud/hpcs-grep11-go/ep11.Attribute" json:"Template,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                                                               `json:"-"`
	XXX_unrecognized     []byte                                                                 `json:"-"`
	XXX_sizecache        int32                                                                  `json:"-"`
}

func (m *UnwrapKeyRequest) Reset()         { *m = UnwrapKeyRequest{} }
func (m *UnwrapKeyRequest) String() string { return proto.CompactTextString(m) }
func (*UnwrapKeyRequest) ProtoMessage()    {}
func (*UnwrapKeyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{60}
}
func (m *UnwrapKeyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnwrapKeyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnwrapKeyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnwrapKeyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnwrapKeyRequest.Merge(m, src)
}
func (m *UnwrapKeyRequest) XXX_Size() int {
	return m.Size()
}
func (m *UnwrapKeyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UnwrapKeyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UnwrapKeyRequest proto.InternalMessageInfo

func (m *UnwrapKeyRequest) GetWrapped() []byte {
	if m != nil {
		return m.Wrapped
	}
	return nil
}

func (m *UnwrapKeyRequest) GetKeK() []byte {
	if m != nil {
		return m.KeK
	}
	return nil
}

func (m *UnwrapKeyRequest) GetMacKey() []byte {
	if m != nil {
		return m.MacKey
	}
	return nil
}

func (m *UnwrapKeyRequest) GetMech() *Mechanism {
	if m != nil {
		return m.Mech
	}
	return nil
}

func (m *UnwrapKeyRequest) GetTemplate() map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute]*AttributeValue {
	if m != nil {
		return m.Template
	}
	return nil
}

type UnwrapKeyResponse struct {
	UnwrappedBytes       []byte   `protobuf:"bytes,7,opt,name=UnwrappedBytes,proto3" json:"UnwrappedBytes,omitempty"`
	CheckSum             []byte   `protobuf:"bytes,8,opt,name=CheckSum,proto3" json:"CheckSum,omitempty"`
	Unwrapped            *KeyBlob `protobuf:"bytes,10,opt,name=Unwrapped,proto3" json:"Unwrapped,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnwrapKeyResponse) Reset()         { *m = UnwrapKeyResponse{} }
func (m *UnwrapKeyResponse) String() string { return proto.CompactTextString(m) }
func (*UnwrapKeyResponse) ProtoMessage()    {}
func (*UnwrapKeyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{61}
}
func (m *UnwrapKeyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnwrapKeyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnwrapKeyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnwrapKeyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnwrapKeyResponse.Merge(m, src)
}
func (m *UnwrapKeyResponse) XXX_Size() int {
	return m.Size()
}
func (m *UnwrapKeyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UnwrapKeyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UnwrapKeyResponse proto.InternalMessageInfo

func (m *UnwrapKeyResponse) GetUnwrappedBytes() []byte {
	if m != nil {
		return m.UnwrappedBytes
	}
	return nil
}

func (m *UnwrapKeyResponse) GetCheckSum() []byte {
	if m != nil {
		return m.CheckSum
	}
	return nil
}

func (m *UnwrapKeyResponse) GetUnwrapped() *KeyBlob {
	if m != nil {
		return m.Unwrapped
	}
	return nil
}

type DeriveKeyRequest struct {
	Mech                 *Mechanism                                                             `protobuf:"bytes,1,opt,name=Mech,proto3" json:"Mech,omitempty"`
	BaseKey              []byte                                                                 `protobuf:"bytes,3,opt,name=BaseKey,proto3" json:"BaseKey,omitempty"`
	Data                 []byte                                                                 `protobuf:"bytes,4,opt,name=Data,proto3" json:"Data,omitempty"`
	Template             map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute]*AttributeValue `protobuf:"bytes,8,rep,name=Template,proto3,castkey=github.com/IBM-Cloud/hpcs-grep11-go/ep11.Attribute" json:"Template,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                                                               `json:"-"`
	XXX_unrecognized     []byte                                                                 `json:"-"`
	XXX_sizecache        int32                                                                  `json:"-"`
}

func (m *DeriveKeyRequest) Reset()         { *m = DeriveKeyRequest{} }
func (m *DeriveKeyRequest) String() string { return proto.CompactTextString(m) }
func (*DeriveKeyRequest) ProtoMessage()    {}
func (*DeriveKeyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{62}
}
func (m *DeriveKeyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveKeyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveKeyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeriveKeyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveKeyRequest.Merge(m, src)
}
func (m *DeriveKeyRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeriveKeyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveKeyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveKeyRequest proto.InternalMessageInfo

func (m *DeriveKeyRequest) GetMech() *Mechanism {
	if m != nil {
		return m.Mech
	}
	return nil
}

func (m *DeriveKeyRequest) GetBaseKey() []byte {
	if m != nil {
		return m.BaseKey
	}
	return nil
}

func (m *DeriveKeyRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *DeriveKeyRequest) GetTemplate() map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute]*AttributeValue {
	if m != nil {
		return m.Template
	}
	return nil
}

type DeriveKeyResponse struct {
	NewKeyBytes          []byte   `protobuf:"bytes,6,opt,name=NewKeyBytes,proto3" json:"NewKeyBytes,omitempty"`
	CheckSum             []byte   `protobuf:"bytes,7,opt,name=CheckSum,proto3" json:"CheckSum,omitempty"`
	NewKey               *KeyBlob `protobuf:"bytes,9,opt,name=NewKey,proto3" json:"NewKey,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeriveKeyResponse) Reset()         { *m = DeriveKeyResponse{} }
func (m *DeriveKeyResponse) String() string { return proto.CompactTextString(m) }
func (*DeriveKeyResponse) ProtoMessage()    {}
func (*DeriveKeyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{63}
}
func (m *DeriveKeyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeriveKeyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeriveKeyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeriveKeyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeriveKeyResponse.Merge(m, src)
}
func (m *DeriveKeyResponse) XXX_Size() int {
	return m.Size()
}
func (m *DeriveKeyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeriveKeyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeriveKeyResponse proto.InternalMessageInfo

func (m *DeriveKeyResponse) GetNewKeyBytes() []byte {
	if m != nil {
		return m.NewKeyBytes
	}
	return nil
}

func (m *DeriveKeyResponse) GetCheckSum() []byte {
	if m != nil {
		return m.CheckSum
	}
	return nil
}

func (m *DeriveKeyResponse) GetNewKey() *KeyBlob {
	if m != nil {
		return m.NewKey
	}
	return nil
}

type GetMechanismListRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetMechanismListRequest) Reset()         { *m = GetMechanismListRequest{} }
func (m *GetMechanismListRequest) String() string { return proto.CompactTextString(m) }
func (*GetMechanismListRequest) ProtoMessage()    {}
func (*GetMechanismListRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{64}
}
func (m *GetMechanismListRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetMechanismListRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetMechanismListRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetMechanismListRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMechanismListRequest.Merge(m, src)
}
func (m *GetMechanismListRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetMechanismListRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMechanismListRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetMechanismListRequest proto.InternalMessageInfo

type GetMechanismListResponse struct {
	Mechs                []github_com_IBM_Cloud_hpcs_grep11_go_ep11.Mechanism `protobuf:"varint,2,rep,packed,name=Mechs,proto3,casttype=github.com/IBM-Cloud/hpcs-grep11-go/ep11.Mechanism" json:"Mechs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                             `json:"-"`
	XXX_unrecognized     []byte                                               `json:"-"`
	XXX_sizecache        int32                                                `json:"-"`
}

func (m *GetMechanismListResponse) Reset()         { *m = GetMechanismListResponse{} }
func (m *GetMechanismListResponse) String() string { return proto.CompactTextString(m) }
func (*GetMechanismListResponse) ProtoMessage()    {}
func (*GetMechanismListResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{65}
}
func (m *GetMechanismListResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetMechanismListResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetMechanismListResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetMechanismListResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMechanismListResponse.Merge(m, src)
}
func (m *GetMechanismListResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetMechanismListResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMechanismListResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetMechanismListResponse proto.InternalMessageInfo

func (m *GetMechanismListResponse) GetMechs() []github_com_IBM_Cloud_hpcs_grep11_go_ep11.Mechanism {
	if m != nil {
		return m.Mechs
	}
	return nil
}

type GetMechanismInfoRequest struct {
	Mech                 github_com_IBM_Cloud_hpcs_grep11_go_ep11.Mechanism `protobuf:"varint,2,opt,name=Mech,proto3,casttype=github.com/IBM-Cloud/hpcs-grep11-go/ep11.Mechanism" json:"Mech,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                           `json:"-"`
	XXX_unrecognized     []byte                                             `json:"-"`
	XXX_sizecache        int32                                              `json:"-"`
}

func (m *GetMechanismInfoRequest) Reset()         { *m = GetMechanismInfoRequest{} }
func (m *GetMechanismInfoRequest) String() string { return proto.CompactTextString(m) }
func (*GetMechanismInfoRequest) ProtoMessage()    {}
func (*GetMechanismInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{66}
}
func (m *GetMechanismInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetMechanismInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetMechanismInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetMechanismInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMechanismInfoRequest.Merge(m, src)
}
func (m *GetMechanismInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetMechanismInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMechanismInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetMechanismInfoRequest proto.InternalMessageInfo

func (m *GetMechanismInfoRequest) GetMech() github_com_IBM_Cloud_hpcs_grep11_go_ep11.Mechanism {
	if m != nil {
		return m.Mech
	}
	return 0
}

type GetMechanismInfoResponse struct {
	MechInfo             *MechanismInfo `protobuf:"bytes,3,opt,name=MechInfo,proto3" json:"MechInfo,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *GetMechanismInfoResponse) Reset()         { *m = GetMechanismInfoResponse{} }
func (m *GetMechanismInfoResponse) String() string { return proto.CompactTextString(m) }
func (*GetMechanismInfoResponse) ProtoMessage()    {}
func (*GetMechanismInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{67}
}
func (m *GetMechanismInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetMechanismInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetMechanismInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetMechanismInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMechanismInfoResponse.Merge(m, src)
}
func (m *GetMechanismInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetMechanismInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMechanismInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetMechanismInfoResponse proto.InternalMessageInfo

func (m *GetMechanismInfoResponse) GetMechInfo() *MechanismInfo {
	if m != nil {
		return m.MechInfo
	}
	return nil
}

type GetAttributeValueRequest struct {
	Object               []byte                                                                 `protobuf:"bytes,1,opt,name=Object,proto3" json:"Object,omitempty"`
	AttributesBytes      map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute][]byte          `protobuf:"bytes,2,rep,name=AttributesBytes,proto3,castkey=github.com/IBM-Cloud/hpcs-grep11-go/ep11.Attribute" json:"AttributesBytes,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Attributes           map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute]*AttributeValue `protobuf:"bytes,3,rep,name=Attributes,proto3,castkey=github.com/IBM-Cloud/hpcs-grep11-go/ep11.Attribute" json:"Attributes,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                                                               `json:"-"`
	XXX_unrecognized     []byte                                                                 `json:"-"`
	XXX_sizecache        int32                                                                  `json:"-"`
}

func (m *GetAttributeValueRequest) Reset()         { *m = GetAttributeValueRequest{} }
func (m *GetAttributeValueRequest) String() string { return proto.CompactTextString(m) }
func (*GetAttributeValueRequest) ProtoMessage()    {}
func (*GetAttributeValueRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{68}
}
func (m *GetAttributeValueRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAttributeValueRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAttributeValueRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAttributeValueRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAttributeValueRequest.Merge(m, src)
}
func (m *GetAttributeValueRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetAttributeValueRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAttributeValueRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetAttributeValueRequest proto.InternalMessageInfo

func (m *GetAttributeValueRequest) GetObject() []byte {
	if m != nil {
		return m.Object
	}
	return nil
}

func (m *GetAttributeValueRequest) GetAttributesBytes() map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute][]byte {
	if m != nil {
		return m.AttributesBytes
	}
	return nil
}

func (m *GetAttributeValueRequest) GetAttributes() map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute]*AttributeValue {
	if m != nil {
		return m.Attributes
	}
	return nil
}

type GetAttributeValueResponse struct {
	AttributesBytes      map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute][]byte          `protobuf:"bytes,2,rep,name=AttributesBytes,proto3,castkey=github.com/IBM-Cloud/hpcs-grep11-go/ep11.Attribute" json:"AttributesBytes,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Attributes           map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute]*AttributeValue `protobuf:"bytes,4,rep,name=Attributes,proto3,castkey=github.com/IBM-Cloud/hpcs-grep11-go/ep11.Attribute" json:"Attributes,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                                                               `json:"-"`
	XXX_unrecognized     []byte                                                                 `json:"-"`
	XXX_sizecache        int32                                                                  `json:"-"`
}

func (m *GetAttributeValueResponse) Reset()         { *m = GetAttributeValueResponse{} }
func (m *GetAttributeValueResponse) String() string { return proto.CompactTextString(m) }
func (*GetAttributeValueResponse) ProtoMessage()    {}
func (*GetAttributeValueResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{69}
}
func (m *GetAttributeValueResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAttributeValueResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAttributeValueResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAttributeValueResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAttributeValueResponse.Merge(m, src)
}
func (m *GetAttributeValueResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetAttributeValueResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAttributeValueResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetAttributeValueResponse proto.InternalMessageInfo

func (m *GetAttributeValueResponse) GetAttributesBytes() map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute][]byte {
	if m != nil {
		return m.AttributesBytes
	}
	return nil
}

func (m *GetAttributeValueResponse) GetAttributes() map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute]*AttributeValue {
	if m != nil {
		return m.Attributes
	}
	return nil
}

type SetAttributeValueRequest struct {
	Object               []byte                                                                 `protobuf:"bytes,1,opt,name=Object,proto3" json:"Object,omitempty"`
	Attributes           map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute]*AttributeValue `protobuf:"bytes,3,rep,name=Attributes,proto3,castkey=github.com/IBM-Cloud/hpcs-grep11-go/ep11.Attribute" json:"Attributes,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                                                               `json:"-"`
	XXX_unrecognized     []byte                                                                 `json:"-"`
	XXX_sizecache        int32                                                                  `json:"-"`
}

func (m *SetAttributeValueRequest) Reset()         { *m = SetAttributeValueRequest{} }
func (m *SetAttributeValueRequest) String() string { return proto.CompactTextString(m) }
func (*SetAttributeValueRequest) ProtoMessage()    {}
func (*SetAttributeValueRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{70}
}
func (m *SetAttributeValueRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetAttributeValueRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetAttributeValueRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetAttributeValueRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetAttributeValueRequest.Merge(m, src)
}
func (m *SetAttributeValueRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetAttributeValueRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetAttributeValueRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetAttributeValueRequest proto.InternalMessageInfo

func (m *SetAttributeValueRequest) GetObject() []byte {
	if m != nil {
		return m.Object
	}
	return nil
}

func (m *SetAttributeValueRequest) GetAttributes() map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute]*AttributeValue {
	if m != nil {
		return m.Attributes
	}
	return nil
}

type SetAttributeValueResponse struct {
	Object               []byte   `protobuf:"bytes,1,opt,name=Object,proto3" json:"Object,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetAttributeValueResponse) Reset()         { *m = SetAttributeValueResponse{} }
func (m *SetAttributeValueResponse) String() string { return proto.CompactTextString(m) }
func (*SetAttributeValueResponse) ProtoMessage()    {}
func (*SetAttributeValueResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{71}
}
func (m *SetAttributeValueResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetAttributeValueResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetAttributeValueResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetAttributeValueResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetAttributeValueResponse.Merge(m, src)
}
func (m *SetAttributeValueResponse) XXX_Size() int {
	return m.Size()
}
func (m *SetAttributeValueResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SetAttributeValueResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SetAttributeValueResponse proto.InternalMessageInfo

func (m *SetAttributeValueResponse) GetObject() []byte {
	if m != nil {
		return m.Object
	}
	return nil
}

type LoginRequest struct {
	Storeid              []byte   `protobuf:"bytes,1,opt,name=Storeid,proto3" json:"Storeid,omitempty"`
	Pin                  []byte   `protobuf:"bytes,2,opt,name=Pin,proto3" json:"Pin,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LoginRequest) Reset()         { *m = LoginRequest{} }
func (m *LoginRequest) String() string { return proto.CompactTextString(m) }
func (*LoginRequest) ProtoMessage()    {}
func (*LoginRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{72}
}
func (m *LoginRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoginRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoginRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoginRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoginRequest.Merge(m, src)
}
func (m *LoginRequest) XXX_Size() int {
	return m.Size()
}
func (m *LoginRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LoginRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LoginRequest proto.InternalMessageInfo

func (m *LoginRequest) GetStoreid() []byte {
	if m != nil {
		return m.Storeid
	}
	return nil
}

func (m *LoginRequest) GetPin() []byte {
	if m != nil {
		return m.Pin
	}
	return nil
}

type LoginResponse struct {
	Pinblob              []byte   `protobuf:"bytes,4,opt,name=Pinblob,proto3" json:"Pinblob,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LoginResponse) Reset()         { *m = LoginResponse{} }
func (m *LoginResponse) String() string { return proto.CompactTextString(m) }
func (*LoginResponse) ProtoMessage()    {}
func (*LoginResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{73}
}
func (m *LoginResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoginResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoginResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoginResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoginResponse.Merge(m, src)
}
func (m *LoginResponse) XXX_Size() int {
	return m.Size()
}
func (m *LoginResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LoginResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LoginResponse proto.InternalMessageInfo

func (m *LoginResponse) GetPinblob() []byte {
	if m != nil {
		return m.Pinblob
	}
	return nil
}

type LogoutRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LogoutRequest) Reset()         { *m = LogoutRequest{} }
func (m *LogoutRequest) String() string { return proto.CompactTextString(m) }
func (*LogoutRequest) ProtoMessage()    {}
func (*LogoutRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{74}
}
func (m *LogoutRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogoutRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogoutRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogoutRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogoutRequest.Merge(m, src)
}
func (m *LogoutRequest) XXX_Size() int {
	return m.Size()
}
func (m *LogoutRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LogoutRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LogoutRequest proto.InternalMessageInfo

type LogoutResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LogoutResponse) Reset()         { *m = LogoutResponse{} }
func (m *LogoutResponse) String() string { return proto.CompactTextString(m) }
func (*LogoutResponse) ProtoMessage()    {}
func (*LogoutResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{75}
}
func (m *LogoutResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogoutResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogoutResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogoutResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogoutResponse.Merge(m, src)
}
func (m *LogoutResponse) XXX_Size() int {
	return m.Size()
}
func (m *LogoutResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LogoutResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LogoutResponse proto.InternalMessageInfo

type Mechanism struct {
	Mechanism github_com_IBM_Cloud_hpcs_grep11_go_ep11.Mechanism `protobuf:"varint,1,opt,name=Mechanism,proto3,casttype=github.com/IBM-Cloud/hpcs-grep11-go/ep11.Mechanism" json:"Mechanism,omitempty"`
	// Types that are valid to be assigned to Parameter:
	//	*Mechanism_ParameterB
	//	*Mechanism_RSAOAEPParameter
	//	*Mechanism_RSAPSSParameter
	//	*Mechanism_ECDH1DeriveParameter
	Parameter            isMechanism_Parameter `protobuf_oneof:"Parameter"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *Mechanism) Reset()         { *m = Mechanism{} }
func (m *Mechanism) String() string { return proto.CompactTextString(m) }
func (*Mechanism) ProtoMessage()    {}
func (*Mechanism) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{76}
}
func (m *Mechanism) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Mechanism) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Mechanism.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Mechanism) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Mechanism.Merge(m, src)
}
func (m *Mechanism) XXX_Size() int {
	return m.Size()
}
func (m *Mechanism) XXX_DiscardUnknown() {
	xxx_messageInfo_Mechanism.DiscardUnknown(m)
}

var xxx_messageInfo_Mechanism proto.InternalMessageInfo

type isMechanism_Parameter interface {
	isMechanism_Parameter()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Mechanism_ParameterB struct {
	ParameterB []byte `protobuf:"bytes,2,opt,name=ParameterB,proto3,oneof" json:"ParameterB,omitempty"`
}
type Mechanism_RSAOAEPParameter struct {
	RSAOAEPParameter *RSAOAEPParm `protobuf:"bytes,3,opt,name=RSAOAEPParameter,proto3,oneof" json:"RSAOAEPParameter,omitempty"`
}
type Mechanism_RSAPSSParameter struct {
	RSAPSSParameter *RSAPSSParm `protobuf:"bytes,4,opt,name=RSAPSSParameter,proto3,oneof" json:"RSAPSSParameter,omitempty"`
}
type Mechanism_ECDH1DeriveParameter struct {
	ECDH1DeriveParameter *ECDH1DeriveParm `protobuf:"bytes,5,opt,name=ECDH1DeriveParameter,proto3,oneof" json:"ECDH1DeriveParameter,omitempty"`
}

func (*Mechanism_ParameterB) isMechanism_Parameter()           {}
func (*Mechanism_RSAOAEPParameter) isMechanism_Parameter()     {}
func (*Mechanism_RSAPSSParameter) isMechanism_Parameter()      {}
func (*Mechanism_ECDH1DeriveParameter) isMechanism_Parameter() {}

func (m *Mechanism) GetParameter() isMechanism_Parameter {
	if m != nil {
		return m.Parameter
	}
	return nil
}

func (m *Mechanism) GetMechanism() github_com_IBM_Cloud_hpcs_grep11_go_ep11.Mechanism {
	if m != nil {
		return m.Mechanism
	}
	return 0
}

func (m *Mechanism) GetParameterB() []byte {
	if x, ok := m.GetParameter().(*Mechanism_ParameterB); ok {
		return x.ParameterB
	}
	return nil
}

func (m *Mechanism) GetRSAOAEPParameter() *RSAOAEPParm {
	if x, ok := m.GetParameter().(*Mechanism_RSAOAEPParameter); ok {
		return x.RSAOAEPParameter
	}
	return nil
}

func (m *Mechanism) GetRSAPSSParameter() *RSAPSSParm {
	if x, ok := m.GetParameter().(*Mechanism_RSAPSSParameter); ok {
		return x.RSAPSSParameter
	}
	return nil
}

func (m *Mechanism) GetECDH1DeriveParameter() *ECDH1DeriveParm {
	if x, ok := m.GetParameter().(*Mechanism_ECDH1DeriveParameter); ok {
		return x.ECDH1DeriveParameter
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Mechanism) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Mechanism_ParameterB)(nil),
		(*Mechanism_RSAOAEPParameter)(nil),
		(*Mechanism_RSAPSSParameter)(nil),
		(*Mechanism_ECDH1DeriveParameter)(nil),
	}
}

type MechanismInfo struct {
	MinKeySize           uint64   `protobuf:"varint,1,opt,name=MinKeySize,proto3" json:"MinKeySize,omitempty"`
	MaxKeySize           uint64   `protobuf:"varint,2,opt,name=MaxKeySize,proto3" json:"MaxKeySize,omitempty"`
	Flags                uint64   `protobuf:"varint,3,opt,name=Flags,proto3" json:"Flags,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MechanismInfo) Reset()         { *m = MechanismInfo{} }
func (m *MechanismInfo) String() string { return proto.CompactTextString(m) }
func (*MechanismInfo) ProtoMessage()    {}
func (*MechanismInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{77}
}
func (m *MechanismInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MechanismInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MechanismInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MechanismInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MechanismInfo.Merge(m, src)
}
func (m *MechanismInfo) XXX_Size() int {
	return m.Size()
}
func (m *MechanismInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MechanismInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MechanismInfo proto.InternalMessageInfo

func (m *MechanismInfo) GetMinKeySize() uint64 {
	if m != nil {
		return m.MinKeySize
	}
	return 0
}

func (m *MechanismInfo) GetMaxKeySize() uint64 {
	if m != nil {
		return m.MaxKeySize
	}
	return 0
}

func (m *MechanismInfo) GetFlags() uint64 {
	if m != nil {
		return m.Flags
	}
	return 0
}

type Grep11Error struct {
	Code                 github_com_IBM_Cloud_hpcs_grep11_go_ep11.Return `protobuf:"varint,1,opt,name=Code,proto3,casttype=github.com/IBM-Cloud/hpcs-grep11-go/ep11.Return" json:"Code,omitempty"`
	Detail               string                                          `protobuf:"bytes,2,opt,name=Detail,proto3" json:"Detail,omitempty"`
	Retry                bool                                            `protobuf:"varint,3,opt,name=Retry,proto3" json:"Retry,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                        `json:"-"`
	XXX_unrecognized     []byte                                          `json:"-"`
	XXX_sizecache        int32                                           `json:"-"`
}

func (m *Grep11Error) Reset()         { *m = Grep11Error{} }
func (m *Grep11Error) String() string { return proto.CompactTextString(m) }
func (*Grep11Error) ProtoMessage()    {}
func (*Grep11Error) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{78}
}
func (m *Grep11Error) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Grep11Error) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Grep11Error.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Grep11Error) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Grep11Error.Merge(m, src)
}
func (m *Grep11Error) XXX_Size() int {
	return m.Size()
}
func (m *Grep11Error) XXX_DiscardUnknown() {
	xxx_messageInfo_Grep11Error.DiscardUnknown(m)
}

var xxx_messageInfo_Grep11Error proto.InternalMessageInfo

func (m *Grep11Error) GetCode() github_com_IBM_Cloud_hpcs_grep11_go_ep11.Return {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *Grep11Error) GetDetail() string {
	if m != nil {
		return m.Detail
	}
	return ""
}

func (m *Grep11Error) GetRetry() bool {
	if m != nil {
		return m.Retry
	}
	return false
}

type RSAOAEPParm struct {
	HashMech             github_com_IBM_Cloud_hpcs_grep11_go_ep11.Mechanism `protobuf:"varint,1,opt,name=HashMech,proto3,casttype=github.com/IBM-Cloud/hpcs-grep11-go/ep11.Mechanism" json:"HashMech,omitempty"`
	Mgf                  RSAOAEPParm_Mask                                   `protobuf:"varint,2,opt,name=Mgf,proto3,enum=grep11.RSAOAEPParm_Mask" json:"Mgf,omitempty"`
	EncodingParmType     RSAOAEPParm_ParmType                               `protobuf:"varint,3,opt,name=EncodingParmType,proto3,enum=grep11.RSAOAEPParm_ParmType" json:"EncodingParmType,omitempty"`
	EncodingParm         []byte                                             `protobuf:"bytes,4,opt,name=EncodingParm,proto3" json:"EncodingParm,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                           `json:"-"`
	XXX_unrecognized     []byte                                             `json:"-"`
	XXX_sizecache        int32                                              `json:"-"`
}

func (m *RSAOAEPParm) Reset()         { *m = RSAOAEPParm{} }
func (m *RSAOAEPParm) String() string { return proto.CompactTextString(m) }
func (*RSAOAEPParm) ProtoMessage()    {}
func (*RSAOAEPParm) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{79}
}
func (m *RSAOAEPParm) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RSAOAEPParm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RSAOAEPParm.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RSAOAEPParm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RSAOAEPParm.Merge(m, src)
}
func (m *RSAOAEPParm) XXX_Size() int {
	return m.Size()
}
func (m *RSAOAEPParm) XXX_DiscardUnknown() {
	xxx_messageInfo_RSAOAEPParm.DiscardUnknown(m)
}

var xxx_messageInfo_RSAOAEPParm proto.InternalMessageInfo

func (m *RSAOAEPParm) GetHashMech() github_com_IBM_Cloud_hpcs_grep11_go_ep11.Mechanism {
	if m != nil {
		return m.HashMech
	}
	return 0
}

func (m *RSAOAEPParm) GetMgf() RSAOAEPParm_Mask {
	if m != nil {
		return m.Mgf
	}
	return RSAOAEPParm_CkgMgf1None
}

func (m *RSAOAEPParm) GetEncodingParmType() RSAOAEPParm_ParmType {
	if m != nil {
		return m.EncodingParmType
	}
	return RSAOAEPParm_CkzNoDataSpecified
}

func (m *RSAOAEPParm) GetEncodingParm() []byte {
	if m != nil {
		return m.EncodingParm
	}
	return nil
}

type RSAPSSParm struct {
	HashMech             github_com_IBM_Cloud_hpcs_grep11_go_ep11.Mechanism `protobuf:"varint,1,opt,name=HashMech,proto3,casttype=github.com/IBM-Cloud/hpcs-grep11-go/ep11.Mechanism" json:"HashMech,omitempty"`
	Mgf                  RSAPSSParm_Mask                                    `protobuf:"varint,2,opt,name=Mgf,proto3,enum=grep11.RSAPSSParm_Mask" json:"Mgf,omitempty"`
	SaltByteCount        uint64                                             `protobuf:"varint,3,opt,name=SaltByteCount,proto3" json:"SaltByteCount,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                           `json:"-"`
	XXX_unrecognized     []byte                                             `json:"-"`
	XXX_sizecache        int32                                              `json:"-"`
}

func (m *RSAPSSParm) Reset()         { *m = RSAPSSParm{} }
func (m *RSAPSSParm) String() string { return proto.CompactTextString(m) }
func (*RSAPSSParm) ProtoMessage()    {}
func (*RSAPSSParm) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{80}
}
func (m *RSAPSSParm) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RSAPSSParm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RSAPSSParm.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RSAPSSParm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RSAPSSParm.Merge(m, src)
}
func (m *RSAPSSParm) XXX_Size() int {
	return m.Size()
}
func (m *RSAPSSParm) XXX_DiscardUnknown() {
	xxx_messageInfo_RSAPSSParm.DiscardUnknown(m)
}

var xxx_messageInfo_RSAPSSParm proto.InternalMessageInfo

func (m *RSAPSSParm) GetHashMech() github_com_IBM_Cloud_hpcs_grep11_go_ep11.Mechanism {
	if m != nil {
		return m.HashMech
	}
	return 0
}

func (m *RSAPSSParm) GetMgf() RSAPSSParm_Mask {
	if m != nil {
		return m.Mgf
	}
	return RSAPSSParm_CkgMgf1None
}

func (m *RSAPSSParm) GetSaltByteCount() uint64 {
	if m != nil {
		return m.SaltByteCount
	}
	return 0
}

type ECDH1DeriveParm struct {
	Kdf                  ECDH1DeriveParm_KeyDerivationFunction `protobuf:"varint,1,opt,name=Kdf,proto3,enum=grep11.ECDH1DeriveParm_KeyDerivationFunction" json:"Kdf,omitempty"`
	SharedData           []byte                                `protobuf:"bytes,2,opt,name=SharedData,proto3" json:"SharedData,omitempty"`
	PublicData           []byte                                `protobuf:"bytes,3,opt,name=PublicData,proto3" json:"PublicData,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                              `json:"-"`
	XXX_unrecognized     []byte                                `json:"-"`
	XXX_sizecache        int32                                 `json:"-"`
}

func (m *ECDH1DeriveParm) Reset()         { *m = ECDH1DeriveParm{} }
func (m *ECDH1DeriveParm) String() string { return proto.CompactTextString(m) }
func (*ECDH1DeriveParm) ProtoMessage()    {}
func (*ECDH1DeriveParm) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{81}
}
func (m *ECDH1DeriveParm) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ECDH1DeriveParm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ECDH1DeriveParm.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ECDH1DeriveParm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ECDH1DeriveParm.Merge(m, src)
}
func (m *ECDH1DeriveParm) XXX_Size() int {
	return m.Size()
}
func (m *ECDH1DeriveParm) XXX_DiscardUnknown() {
	xxx_messageInfo_ECDH1DeriveParm.DiscardUnknown(m)
}

var xxx_messageInfo_ECDH1DeriveParm proto.InternalMessageInfo

func (m *ECDH1DeriveParm) GetKdf() ECDH1DeriveParm_KeyDerivationFunction {
	if m != nil {
		return m.Kdf
	}
	return ECDH1DeriveParm_CkdNotUsed0
}

func (m *ECDH1DeriveParm) GetSharedData() []byte {
	if m != nil {
		return m.SharedData
	}
	return nil
}

func (m *ECDH1DeriveParm) GetPublicData() []byte {
	if m != nil {
		return m.PublicData
	}
	return nil
}

type HMACGeneralParm struct {
	ReturnByteCount      uint32   `protobuf:"varint,1,opt,name=ReturnByteCount,proto3" json:"ReturnByteCount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HMACGeneralParm) Reset()         { *m = HMACGeneralParm{} }
func (m *HMACGeneralParm) String() string { return proto.CompactTextString(m) }
func (*HMACGeneralParm) ProtoMessage()    {}
func (*HMACGeneralParm) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{82}
}
func (m *HMACGeneralParm) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HMACGeneralParm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HMACGeneralParm.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HMACGeneralParm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HMACGeneralParm.Merge(m, src)
}
func (m *HMACGeneralParm) XXX_Size() int {
	return m.Size()
}
func (m *HMACGeneralParm) XXX_DiscardUnknown() {
	xxx_messageInfo_HMACGeneralParm.DiscardUnknown(m)
}

var xxx_messageInfo_HMACGeneralParm proto.InternalMessageInfo

func (m *HMACGeneralParm) GetReturnByteCount() uint32 {
	if m != nil {
		return m.ReturnByteCount
	}
	return 0
}

type RewrapKeyBlobRequest struct {
	WrappedKey           []byte   `protobuf:"bytes,1,opt,name=WrappedKey,proto3" json:"WrappedKey,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RewrapKeyBlobRequest) Reset()         { *m = RewrapKeyBlobRequest{} }
func (m *RewrapKeyBlobRequest) String() string { return proto.CompactTextString(m) }
func (*RewrapKeyBlobRequest) ProtoMessage()    {}
func (*RewrapKeyBlobRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{83}
}
func (m *RewrapKeyBlobRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewrapKeyBlobRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewrapKeyBlobRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewrapKeyBlobRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewrapKeyBlobRequest.Merge(m, src)
}
func (m *RewrapKeyBlobRequest) XXX_Size() int {
	return m.Size()
}
func (m *RewrapKeyBlobRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RewrapKeyBlobRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RewrapKeyBlobRequest proto.InternalMessageInfo

func (m *RewrapKeyBlobRequest) GetWrappedKey() []byte {
	if m != nil {
		return m.WrappedKey
	}
	return nil
}

type RewrapKeyBlobResponse struct {
	RewrappedKey         []byte   `protobuf:"bytes,1,opt,name=RewrappedKey,proto3" json:"RewrappedKey,omitempty"`
	KeyBlob              *KeyBlob `protobuf:"bytes,2,opt,name=KeyBlob,proto3" json:"KeyBlob,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RewrapKeyBlobResponse) Reset()         { *m = RewrapKeyBlobResponse{} }
func (m *RewrapKeyBlobResponse) String() string { return proto.CompactTextString(m) }
func (*RewrapKeyBlobResponse) ProtoMessage()    {}
func (*RewrapKeyBlobResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{84}
}
func (m *RewrapKeyBlobResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewrapKeyBlobResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewrapKeyBlobResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewrapKeyBlobResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewrapKeyBlobResponse.Merge(m, src)
}
func (m *RewrapKeyBlobResponse) XXX_Size() int {
	return m.Size()
}
func (m *RewrapKeyBlobResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RewrapKeyBlobResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RewrapKeyBlobResponse proto.InternalMessageInfo

func (m *RewrapKeyBlobResponse) GetRewrappedKey() []byte {
	if m != nil {
		return m.RewrappedKey
	}
	return nil
}

func (m *RewrapKeyBlobResponse) GetKeyBlob() *KeyBlob {
	if m != nil {
		return m.KeyBlob
	}
	return nil
}

type AttributeValue struct {
	// Types that are valid to be assigned to OneAttr:
	//	*AttributeValue_AttributeB
	//	*AttributeValue_AttributeTF
	//	*AttributeValue_AttributeI
	OneAttr              isAttributeValue_OneAttr `protobuf_oneof:"one_attr"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *AttributeValue) Reset()         { *m = AttributeValue{} }
func (m *AttributeValue) String() string { return proto.CompactTextString(m) }
func (*AttributeValue) ProtoMessage()    {}
func (*AttributeValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{85}
}
func (m *AttributeValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttributeValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttributeValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttributeValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttributeValue.Merge(m, src)
}
func (m *AttributeValue) XXX_Size() int {
	return m.Size()
}
func (m *AttributeValue) XXX_DiscardUnknown() {
	xxx_messageInfo_AttributeValue.DiscardUnknown(m)
}

var xxx_messageInfo_AttributeValue proto.InternalMessageInfo

type isAttributeValue_OneAttr interface {
	isAttributeValue_OneAttr()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AttributeValue_AttributeB struct {
	AttributeB []byte `protobuf:"bytes,1,opt,name=AttributeB,proto3,oneof" json:"AttributeB"`
}
type AttributeValue_AttributeTF struct {
	AttributeTF bool `protobuf:"varint,2,opt,name=AttributeTF,proto3,oneof" json:"AttributeTF"`
}
type AttributeValue_AttributeI struct {
	AttributeI int64 `protobuf:"varint,3,opt,name=AttributeI,proto3,oneof" json:"AttributeI"`
}

func (*AttributeValue_AttributeB) isAttributeValue_OneAttr()  {}
func (*AttributeValue_AttributeTF) isAttributeValue_OneAttr() {}
func (*AttributeValue_AttributeI) isAttributeValue_OneAttr()  {}

func (m *AttributeValue) GetOneAttr() isAttributeValue_OneAttr {
	if m != nil {
		return m.OneAttr
	}
	return nil
}

func (m *AttributeValue) GetAttributeB() []byte {
	if x, ok := m.GetOneAttr().(*AttributeValue_AttributeB); ok {
		return x.AttributeB
	}
	return nil
}

func (m *AttributeValue) GetAttributeTF() bool {
	if x, ok := m.GetOneAttr().(*AttributeValue_AttributeTF); ok {
		return x.AttributeTF
	}
	return false
}

func (m *AttributeValue) GetAttributeI() int64 {
	if x, ok := m.GetOneAttr().(*AttributeValue_AttributeI); ok {
		return x.AttributeI
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AttributeValue) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AttributeValue_AttributeB)(nil),
		(*AttributeValue_AttributeTF)(nil),
		(*AttributeValue_AttributeI)(nil),
	}
}

type KeyBlob struct {
	KeyBlobID            []byte                                                                 `protobuf:"bytes,1,opt,name=KeyBlobID,proto3" json:"KeyBlobID,omitempty"`
	Version              int64                                                                  `protobuf:"varint,2,opt,name=Version,proto3" json:"Version,omitempty"`
	TxID                 []byte                                                                 `protobuf:"bytes,3,opt,name=TxID,proto3" json:"TxID,omitempty"`
	Attributes           map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute]*AttributeValue `protobuf:"bytes,4,rep,name=Attributes,proto3,castkey=github.com/IBM-Cloud/hpcs-grep11-go/ep11.Attribute" json:"Attributes,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	KeyBlobs             [][]byte                                                               `protobuf:"bytes,5,rep,name=KeyBlobs,proto3" json:"KeyBlobs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                               `json:"-"`
	XXX_unrecognized     []byte                                                                 `json:"-"`
	XXX_sizecache        int32                                                                  `json:"-"`
}

func (m *KeyBlob) Reset()         { *m = KeyBlob{} }
func (m *KeyBlob) String() string { return proto.CompactTextString(m) }
func (*KeyBlob) ProtoMessage()    {}
func (*KeyBlob) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad098daeda4239f7, []int{86}
}
func (m *KeyBlob) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyBlob) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyBlob.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyBlob) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyBlob.Merge(m, src)
}
func (m *KeyBlob) XXX_Size() int {
	return m.Size()
}
func (m *KeyBlob) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyBlob.DiscardUnknown(m)
}

var xxx_messageInfo_KeyBlob proto.InternalMessageInfo

func (m *KeyBlob) GetKeyBlobID() []byte {
	if m != nil {
		return m.KeyBlobID
	}
	return nil
}

func (m *KeyBlob) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *KeyBlob) GetTxID() []byte {
	if m != nil {
		return m.TxID
	}
	return nil
}

func (m *KeyBlob) GetAttributes() map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute]*AttributeValue {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *KeyBlob) GetKeyBlobs() [][]byte {
	if m != nil {
		return m.KeyBlobs
	}
	return nil
}

func init() {
	proto.RegisterEnum("grep11.RSAOAEPParm_Mask", RSAOAEPParm_Mask_name, RSAOAEPParm_Mask_value)
	proto.RegisterEnum("grep11.RSAOAEPParm_ParmType", RSAOAEPParm_ParmType_name, RSAOAEPParm_ParmType_value)
	proto.RegisterEnum("grep11.RSAPSSParm_Mask", RSAPSSParm_Mask_name, RSAPSSParm_Mask_value)
	proto.RegisterEnum("grep11.ECDH1DeriveParm_KeyDerivationFunction", ECDH1DeriveParm_KeyDerivationFunction_name, ECDH1DeriveParm_KeyDerivationFunction_value)
	proto.RegisterType((*GenerateRandomRequest)(nil), "grep11.GenerateRandomRequest")
	proto.RegisterType((*GenerateRandomResponse)(nil), "grep11.GenerateRandomResponse")
	proto.RegisterType((*DigestInitRequest)(nil), "grep11.DigestInitRequest")
	proto.RegisterType((*DigestInitResponse)(nil), "grep11.DigestInitResponse")
	proto.RegisterType((*DigestRequest)(nil), "grep11.DigestRequest")
	proto.RegisterType((*DigestResponse)(nil), "grep11.DigestResponse")
	proto.RegisterType((*DigestUpdateRequest)(nil), "grep11.DigestUpdateRequest")
	proto.RegisterType((*DigestUpdateResponse)(nil), "grep11.DigestUpdateResponse")
	proto.RegisterType((*DigestKeyRequest)(nil), "grep11.DigestKeyRequest")
	proto.RegisterType((*DigestKeyResponse)(nil), "grep11.DigestKeyResponse")
	proto.RegisterType((*DigestFinalRequest)(nil), "grep11.DigestFinalRequest")
	proto.RegisterType((*DigestFinalResponse)(nil), "grep11.DigestFinalResponse")
	proto.RegisterType((*DigestSingleRequest)(nil), "grep11.DigestSingleRequest")
	proto.RegisterType((*DigestSingleResponse)(nil), "grep11.DigestSingleResponse")
	proto.RegisterType((*EncryptInitRequest)(nil), "grep11.EncryptInitRequest")
	proto.RegisterType((*EncryptInitResponse)(nil), "grep11.EncryptInitResponse")
	proto.RegisterType((*DecryptInitRequest)(nil), "grep11.DecryptInitRequest")
	proto.RegisterType((*DecryptInitResponse)(nil), "grep11.DecryptInitResponse")
	proto.RegisterType((*EncryptUpdateRequest)(nil), "grep11.EncryptUpdateRequest")
	proto.RegisterType((*EncryptUpdateResponse)(nil), "grep11.EncryptUpdateResponse")
	proto.RegisterType((*DecryptUpdateRequest)(nil), "grep11.DecryptUpdateRequest")
	proto.RegisterType((*DecryptUpdateResponse)(nil), "grep11.DecryptUpdateResponse")
	proto.RegisterType((*EncryptRequest)(nil), "grep11.EncryptRequest")
	proto.RegisterType((*EncryptResponse)(nil), "grep11.EncryptResponse")
	proto.RegisterType((*DecryptRequest)(nil), "grep11.DecryptRequest")
	proto.RegisterType((*DecryptResponse)(nil), "grep11.DecryptResponse")
	proto.RegisterType((*EncryptFinalRequest)(nil), "grep11.EncryptFinalRequest")
	proto.RegisterType((*EncryptFinalResponse)(nil), "grep11.EncryptFinalResponse")
	proto.RegisterType((*DecryptFinalRequest)(nil), "grep11.DecryptFinalRequest")
	proto.RegisterType((*DecryptFinalResponse)(nil), "grep11.DecryptFinalResponse")
	proto.RegisterType((*EncryptSingleRequest)(nil), "grep11.EncryptSingleRequest")
	proto.RegisterType((*EncryptSingleResponse)(nil), "grep11.EncryptSingleResponse")
	proto.RegisterType((*DecryptSingleRequest)(nil), "grep11.DecryptSingleRequest")
	proto.RegisterType((*DecryptSingleResponse)(nil), "grep11.DecryptSingleResponse")
	proto.RegisterType((*SignInitRequest)(nil), "grep11.SignInitRequest")
	proto.RegisterType((*SignInitResponse)(nil), "grep11.SignInitResponse")
	proto.RegisterType((*VerifyInitRequest)(nil), "grep11.VerifyInitRequest")
	proto.RegisterType((*VerifyInitResponse)(nil), "grep11.VerifyInitResponse")
	proto.RegisterType((*SignUpdateRequest)(nil), "grep11.SignUpdateRequest")
	proto.RegisterType((*SignUpdateResponse)(nil), "grep11.SignUpdateResponse")
	proto.RegisterType((*VerifyUpdateRequest)(nil), "grep11.VerifyUpdateRequest")
	proto.RegisterType((*VerifyUpdateResponse)(nil), "grep11.VerifyUpdateResponse")
	proto.RegisterType((*SignFinalRequest)(nil), "grep11.SignFinalRequest")
	proto.RegisterType((*SignFinalResponse)(nil), "grep11.SignFinalResponse")
	proto.RegisterType((*VerifyFinalRequest)(nil), "grep11.VerifyFinalRequest")
	proto.RegisterType((*VerifyFinalResponse)(nil), "grep11.VerifyFinalResponse")
	proto.RegisterType((*SignRequest)(nil), "grep11.SignRequest")
	proto.RegisterType((*SignResponse)(nil), "grep11.SignResponse")
	proto.RegisterType((*VerifyRequest)(nil), "grep11.VerifyRequest")
	proto.RegisterType((*VerifyResponse)(nil), "grep11.VerifyResponse")
	proto.RegisterType((*SignSingleRequest)(nil), "grep11.SignSingleRequest")
	proto.RegisterType((*SignSingleResponse)(nil), "grep11.SignSingleResponse")
	proto.RegisterType((*VerifySingleRequest)(nil), "grep11.VerifySingleRequest")
	proto.RegisterType((*VerifySingleResponse)(nil), "grep11.VerifySingleResponse")
	proto.RegisterType((*GenerateKeyRequest)(nil), "grep11.GenerateKeyRequest")
	proto.RegisterMapType((map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute]*AttributeValue)(nil), "grep11.GenerateKeyRequest.TemplateEntry")
	proto.RegisterType((*GenerateKeyResponse)(nil), "grep11.GenerateKeyResponse")
	proto.RegisterType((*GenerateKeyPairRequest)(nil), "grep11.GenerateKeyPairRequest")
	proto.RegisterMapType((map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute]*AttributeValue)(nil), "grep11.GenerateKeyPairRequest.PrivKeyTemplateEntry")
	proto.RegisterMapType((map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute]*AttributeValue)(nil), "grep11.GenerateKeyPairRequest.PubKeyTemplateEntry")
	proto.RegisterType((*GenerateKeyPairResponse)(nil), "grep11.GenerateKeyPairResponse")
	proto.RegisterType((*WrapKeyRequest)(nil), "grep11.WrapKeyRequest")
	proto.RegisterType((*WrapKeyResponse)(nil), "grep11.WrapKeyResponse")
	proto.RegisterType((*UnwrapKeyRequest)(nil), "grep11.UnwrapKeyRequest")
	proto.RegisterMapType((map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute]*AttributeValue)(nil), "grep11.UnwrapKeyRequest.TemplateEntry")
	proto.RegisterType((*UnwrapKeyResponse)(nil), "grep11.UnwrapKeyResponse")
	proto.RegisterType((*DeriveKeyRequest)(nil), "grep11.DeriveKeyRequest")
	proto.RegisterMapType((map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute]*AttributeValue)(nil), "grep11.DeriveKeyRequest.TemplateEntry")
	proto.RegisterType((*DeriveKeyResponse)(nil), "grep11.DeriveKeyResponse")
	proto.RegisterType((*GetMechanismListRequest)(nil), "grep11.GetMechanismListRequest")
	proto.RegisterType((*GetMechanismListResponse)(nil), "grep11.GetMechanismListResponse")
	proto.RegisterType((*GetMechanismInfoRequest)(nil), "grep11.GetMechanismInfoRequest")
	proto.RegisterType((*GetMechanismInfoResponse)(nil), "grep11.GetMechanismInfoResponse")
	proto.RegisterType((*GetAttributeValueRequest)(nil), "grep11.GetAttributeValueRequest")
	proto.RegisterMapType((map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute][]byte)(nil), "grep11.GetAttributeValueRequest.AttributesBytesEntry")
	proto.RegisterMapType((map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute]*AttributeValue)(nil), "grep11.GetAttributeValueRequest.AttributesEntry")
	proto.RegisterType((*GetAttributeValueResponse)(nil), "grep11.GetAttributeValueResponse")
	proto.RegisterMapType((map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute][]byte)(nil), "grep11.GetAttributeValueResponse.AttributesBytesEntry")
	proto.RegisterMapType((map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute]*AttributeValue)(nil), "grep11.GetAttributeValueResponse.AttributesEntry")
	proto.RegisterType((*SetAttributeValueRequest)(nil), "grep11.SetAttributeValueRequest")
	proto.RegisterMapType((map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute]*AttributeValue)(nil), "grep11.SetAttributeValueRequest.AttributesEntry")
	proto.RegisterType((*SetAttributeValueResponse)(nil), "grep11.SetAttributeValueResponse")
	proto.RegisterType((*LoginRequest)(nil), "grep11.LoginRequest")
	proto.RegisterType((*LoginResponse)(nil), "grep11.LoginResponse")
	proto.RegisterType((*LogoutRequest)(nil), "grep11.LogoutRequest")
	proto.RegisterType((*LogoutResponse)(nil), "grep11.LogoutResponse")
	proto.RegisterType((*Mechanism)(nil), "grep11.Mechanism")
	proto.RegisterType((*MechanismInfo)(nil), "grep11.MechanismInfo")
	proto.RegisterType((*Grep11Error)(nil), "grep11.Grep11Error")
	proto.RegisterType((*RSAOAEPParm)(nil), "grep11.RSAOAEPParm")
	proto.RegisterType((*RSAPSSParm)(nil), "grep11.RSAPSSParm")
	proto.RegisterType((*ECDH1DeriveParm)(nil), "grep11.ECDH1DeriveParm")
	proto.RegisterType((*HMACGeneralParm)(nil), "grep11.HMACGeneralParm")
	proto.RegisterType((*RewrapKeyBlobRequest)(nil), "grep11.RewrapKeyBlobRequest")
	proto.RegisterType((*RewrapKeyBlobResponse)(nil), "grep11.RewrapKeyBlobResponse")
	proto.RegisterType((*AttributeValue)(nil), "grep11.AttributeValue")
	proto.RegisterType((*KeyBlob)(nil), "grep11.KeyBlob")
	proto.RegisterMapType((map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute]*AttributeValue)(nil), "grep11.KeyBlob.AttributesEntry")
}

func init() { proto.RegisterFile("server.proto", fileDescriptor_ad098daeda4239f7) }

var fileDescriptor_ad098daeda4239f7 = []byte{
	// 2911 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x3b, 0xcd, 0x6f, 0x1b, 0xc7,
	0xf5, 0x5c, 0x92, 0x92, 0xa8, 0x47, 0x89, 0xa4, 0x46, 0x1f, 0xa6, 0x19, 0x45, 0x56, 0x16, 0xbf,
	0x5f, 0x22, 0x3b, 0x91, 0x1c, 0x51, 0xb6, 0x92, 0xb8, 0x69, 0x0d, 0x53, 0x92, 0x23, 0x55, 0x96,
	0xc3, 0x2e, 0xed, 0x04, 0xcd, 0xa5, 0x58, 0x91, 0x23, 0x6a, 0x2b, 0x6a, 0x97, 0x5d, 0x2e, 0x9d,
	0xc8, 0xe8, 0xa9, 0x28, 0x82, 0xf6, 0xd2, 0x43, 0xd1, 0xa2, 0xbd, 0xf7, 0xd0, 0x4b, 0x81, 0x16,
	0x28, 0x0a, 0xf4, 0x5a, 0xa0, 0x87, 0x9e, 0x8a, 0xfe, 0x03, 0x75, 0x0b, 0x1f, 0x73, 0xec, 0x31,
	0xa7, 0x62, 0x77, 0x66, 0xe7, 0x6b, 0x87, 0xd4, 0x97, 0xdd, 0x22, 0xe8, 0x49, 0x9c, 0x37, 0x6f,
	0xde, 0x7b, 0xf3, 0xbe, 0xe6, 0xed, 0xcc, 0x13, 0x4c, 0xf4, 0xb0, 0xff, 0x04, 0xfb, 0x2b, 0x5d,
	0xdf, 0x0b, 0x3c, 0x34, 0xda, 0xf6, 0x71, 0x77, 0x75, 0xb5, 0x02, 0x6d, 0xaf, 0xed, 0x11, 0x98,
	0x79, 0x1d, 0x66, 0x3f, 0xc0, 0x2e, 0xf6, 0xed, 0x00, 0x5b, 0xb6, 0xdb, 0xf2, 0x8e, 0x2d, 0xfc,
	0xbd, 0x3e, 0xee, 0x05, 0xa8, 0x04, 0x99, 0x07, 0xd8, 0x2d, 0x1b, 0x8b, 0xc6, 0x52, 0xd6, 0x0a,
	0x7f, 0x9a, 0x37, 0x60, 0x4e, 0x45, 0xed, 0x75, 0x3d, 0xb7, 0x87, 0x43, 0x5c, 0xcb, 0x6d, 0x45,
	0xb8, 0x13, 0x56, 0xf8, 0xd3, 0xbc, 0x03, 0x53, 0x9b, 0x4e, 0x1b, 0xf7, 0x82, 0x1d, 0xd7, 0x09,
	0x62, 0x92, 0xff, 0x0f, 0xd9, 0x3d, 0xdc, 0x3c, 0x2c, 0xa7, 0x17, 0x8d, 0xa5, 0x7c, 0x75, 0x6a,
	0x85, 0x88, 0xb3, 0x12, 0xc2, 0x6c, 0xd7, 0xe9, 0x1d, 0x5b, 0xd1, 0xb4, 0x79, 0x03, 0x90, 0xb8,
	0x96, 0xf2, 0x98, 0x81, 0x91, 0x46, 0x60, 0x07, 0x98, 0x72, 0x21, 0x03, 0xf3, 0x3d, 0x98, 0x24,
	0xb8, 0x31, 0x0f, 0x2d, 0x1a, 0x42, 0x90, 0xdd, 0xb4, 0x03, 0x3b, 0xe2, 0x3c, 0x61, 0x45, 0xbf,
	0xcd, 0x25, 0x28, 0xc4, 0x4b, 0x29, 0x8b, 0x39, 0x18, 0x25, 0x90, 0x72, 0x26, 0xc2, 0xa3, 0x23,
	0xf3, 0x2e, 0x4c, 0x93, 0x5f, 0x8f, 0xbb, 0xad, 0x70, 0xf3, 0xe7, 0x66, 0xf5, 0x16, 0xcc, 0xc8,
	0x04, 0x86, 0xee, 0xe9, 0x0e, 0x94, 0x08, 0xf6, 0x2e, 0x3e, 0x19, 0xce, 0xab, 0x04, 0x99, 0x5d,
	0x7c, 0x42, 0x59, 0x85, 0x3f, 0xcd, 0xeb, 0xb1, 0xde, 0xa3, 0xb5, 0x43, 0xd9, 0x30, 0x35, 0xdf,
	0x77, 0x5c, 0xbb, 0x33, 0x94, 0x91, 0xb9, 0x1c, 0x6b, 0x80, 0xe2, 0x26, 0x14, 0x96, 0x96, 0x14,
	0x56, 0x8f, 0xd1, 0x1b, 0x8e, 0xdb, 0xee, 0x60, 0xd5, 0xfe, 0xc6, 0x50, 0xfb, 0x6b, 0x35, 0xb8,
	0x12, 0x6b, 0x30, 0xa6, 0x78, 0x8a, 0xc9, 0xf6, 0x00, 0x6d, 0xb9, 0x4d, 0xff, 0xa4, 0x7b, 0x01,
	0x07, 0x8c, 0xd5, 0x9a, 0xe1, 0x6a, 0x7d, 0x13, 0xa6, 0x25, 0x72, 0x43, 0x15, 0xbb, 0x07, 0x68,
	0x13, 0xbf, 0x50, 0xde, 0x12, 0xb9, 0xa1, 0xbc, 0x6b, 0x30, 0x43, 0x05, 0x3d, 0x8b, 0xaf, 0xce,
	0xc0, 0x48, 0xbd, 0x63, 0x3b, 0x2e, 0x55, 0x35, 0x19, 0x98, 0x3b, 0x30, 0xab, 0xd0, 0x18, 0xc6,
	0x12, 0x55, 0x20, 0xb7, 0xe1, 0x74, 0x0f, 0xb1, 0x8f, 0x5b, 0x54, 0x6c, 0x36, 0x36, 0xb7, 0x61,
	0x86, 0xca, 0x7e, 0x16, 0x71, 0x44, 0x4a, 0x69, 0x85, 0xd2, 0x06, 0xcc, 0x2a, 0x94, 0x86, 0x0a,
	0xc5, 0x76, 0x96, 0x11, 0x77, 0xf6, 0x3e, 0x14, 0xe8, 0xce, 0x2e, 0xa2, 0x97, 0x65, 0x28, 0xb2,
	0xd5, 0x94, 0xf9, 0xb0, 0xbd, 0xd7, 0xa0, 0x40, 0x25, 0xbe, 0xf8, 0xae, 0xdf, 0x80, 0x22, 0xa3,
	0xc1, 0xf7, 0xab, 0xd9, 0x19, 0x77, 0xd0, 0x33, 0x44, 0x73, 0x95, 0x39, 0x89, 0x1c, 0xce, 0xc3,
	0x24, 0xe1, 0x5e, 0x78, 0x06, 0x06, 0x6f, 0x31, 0xb3, 0xcb, 0x0c, 0xf4, 0x7a, 0xc5, 0x4c, 0x1c,
	0x39, 0x5d, 0xd0, 0x50, 0x30, 0x58, 0x28, 0x9c, 0x35, 0x86, 0xf4, 0x2a, 0x5a, 0x63, 0x6e, 0xad,
	0xe4, 0x10, 0x71, 0xdb, 0x59, 0x65, 0xdb, 0x47, 0x6c, 0x27, 0x2f, 0x48, 0xb6, 0x61, 0x1e, 0xb3,
	0xcc, 0x7c, 0x5c, 0x91, 0x90, 0x6d, 0x28, 0x2b, 0x6e, 0xc8, 0x82, 0x62, 0xc3, 0x69, 0xbb, 0x17,
	0x48, 0x32, 0x65, 0x18, 0xab, 0xfb, 0xce, 0x13, 0x9e, 0x68, 0xe2, 0xa1, 0xb9, 0x04, 0x25, 0x4e,
	0x73, 0x68, 0xa6, 0xb1, 0x60, 0xea, 0x23, 0xec, 0x3b, 0x07, 0x27, 0x17, 0xe0, 0x3f, 0x07, 0xa3,
	0xf5, 0xfe, 0x3e, 0x67, 0x4f, 0x47, 0xe1, 0x91, 0x24, 0xd2, 0x1c, 0xca, 0xff, 0xeb, 0x30, 0x15,
	0x4a, 0x7a, 0xd1, 0x23, 0xf9, 0x06, 0x20, 0x71, 0xf9, 0x50, 0x56, 0x77, 0x61, 0x9a, 0x88, 0x75,
	0x89, 0xf3, 0x5f, 0x26, 0x30, 0x94, 0x1d, 0xb5, 0xc1, 0x19, 0xe2, 0x6c, 0x95, 0xe8, 0x40, 0x0e,
	0xb2, 0x79, 0x18, 0x0f, 0x81, 0x76, 0xd0, 0xf7, 0x31, 0x95, 0x82, 0x03, 0xcc, 0xed, 0x58, 0xc5,
	0xa7, 0x93, 0x3f, 0x85, 0xd2, 0x6c, 0xac, 0x15, 0x89, 0xbd, 0xf9, 0x0e, 0xe4, 0x43, 0x9c, 0x8b,
	0x28, 0x69, 0x82, 0x2c, 0xd4, 0xed, 0x23, 0xa3, 0x72, 0xff, 0x18, 0x26, 0x09, 0xf7, 0x73, 0x33,
	0x3a, 0x85, 0x70, 0x09, 0x0a, 0x31, 0x61, 0xba, 0xa3, 0x43, 0xa2, 0x65, 0x39, 0x01, 0x08, 0x21,
	0x64, 0x48, 0x21, 0x74, 0xd6, 0x18, 0x88, 0x25, 0xcb, 0x08, 0x2a, 0xa8, 0x12, 0xa7, 0x54, 0xa2,
	0x5f, 0x92, 0x37, 0xab, 0xca, 0xfb, 0xb9, 0x11, 0xdb, 0x41, 0x16, 0x90, 0xc7, 0x98, 0x21, 0xc6,
	0xd8, 0x25, 0xc4, 0x3b, 0x45, 0x90, 0xb9, 0xd8, 0xc9, 0x65, 0xf1, 0xcd, 0x9f, 0xa4, 0x01, 0xc5,
	0xdf, 0x0d, 0x42, 0x45, 0x7b, 0xc6, 0x62, 0xf0, 0xfb, 0x90, 0x7b, 0x84, 0x8f, 0xbb, 0x9d, 0xd0,
	0xb2, 0xa3, 0x8b, 0x99, 0xa5, 0x7c, 0x75, 0x29, 0x46, 0x4d, 0x12, 0x5d, 0x89, 0x51, 0xb7, 0xdc,
	0xc0, 0x3f, 0xa9, 0xad, 0xff, 0xe0, 0x1f, 0xd7, 0xaa, 0x6d, 0x27, 0x38, 0xec, 0xef, 0xaf, 0x34,
	0xbd, 0xe3, 0x9b, 0x3b, 0xb5, 0xbd, 0xe5, 0x8d, 0x8e, 0xd7, 0x6f, 0xdd, 0x3c, 0xec, 0x36, 0x7b,
	0xcb, 0x84, 0xcc, 0x72, 0xdb, 0xbb, 0x19, 0x91, 0xbb, 0x17, 0x04, 0xbe, 0xb3, 0xdf, 0x0f, 0xb0,
	0xc5, 0x38, 0x56, 0x1a, 0x30, 0x29, 0x91, 0x0c, 0xf3, 0xfe, 0x11, 0x55, 0x69, 0xd6, 0x0a, 0x7f,
	0xa2, 0xb7, 0x60, 0xe4, 0x89, 0xdd, 0xe9, 0x63, 0xaa, 0xd0, 0xb9, 0x58, 0x3a, 0x46, 0xee, 0xa3,
	0x70, 0xd6, 0x22, 0x48, 0x77, 0xd2, 0xef, 0x1a, 0x66, 0x17, 0xa6, 0x25, 0xd1, 0xf9, 0x31, 0xb4,
	0x8b, 0x4f, 0x6a, 0x27, 0x01, 0xee, 0xc5, 0xc7, 0x50, 0x3c, 0x8e, 0x4e, 0x8d, 0x43, 0xdc, 0x3c,
	0x6a, 0xf4, 0x8f, 0xcb, 0x23, 0xf4, 0xd4, 0xa0, 0x63, 0xf4, 0x1a, 0x39, 0x8a, 0xc6, 0x22, 0xf6,
	0xc5, 0x98, 0x7d, 0xb8, 0xb4, 0xe3, 0xed, 0x93, 0x12, 0xf2, 0x57, 0x59, 0xfe, 0xe9, 0xb6, 0x8b,
	0x4f, 0xea, 0xb6, 0xe3, 0x9f, 0xd3, 0x0c, 0x3f, 0x37, 0xa0, 0x48, 0x1d, 0x9c, 0x99, 0x63, 0x2c,
	0x32, 0xc7, 0x9a, 0xc6, 0x1c, 0x02, 0x83, 0x15, 0x65, 0xd5, 0xe5, 0x2c, 0xa3, 0xca, 0x80, 0x7e,
	0x6a, 0x40, 0x81, 0x38, 0x36, 0x13, 0x2b, 0x17, 0x89, 0x55, 0x3d, 0x4d, 0x2c, 0x69, 0xd1, 0xe5,
	0xa4, 0x52, 0x24, 0xa8, 0x7c, 0x02, 0x33, 0xba, 0x5d, 0xbf, 0x08, 0xe7, 0xa9, 0x7c, 0x1b, 0xa6,
	0x35, 0xa2, 0xbf, 0x10, 0xbf, 0xfc, 0xbd, 0x01, 0x57, 0x12, 0xda, 0xa2, 0xce, 0x69, 0xc2, 0x04,
	0xdd, 0x12, 0x71, 0x50, 0xe2, 0x84, 0x12, 0x0c, 0x2d, 0x42, 0x9e, 0x88, 0x46, 0x50, 0x46, 0x23,
	0x14, 0x11, 0x84, 0xae, 0xf3, 0xa4, 0x39, 0xae, 0x77, 0x57, 0x96, 0x45, 0xdf, 0x60, 0xe9, 0x0b,
	0xf4, 0x98, 0x71, 0xcd, 0xd0, 0x83, 0xc2, 0xc7, 0xbe, 0xdd, 0x15, 0x32, 0x4b, 0xb2, 0x36, 0x8b,
	0x20, 0xbb, 0xfc, 0x3b, 0x79, 0x37, 0xcc, 0x8e, 0x7b, 0x76, 0x53, 0xa8, 0x40, 0xc8, 0x88, 0x85,
	0x43, 0x76, 0xf8, 0x15, 0xc5, 0x9b, 0x50, 0x64, 0x4c, 0xa9, 0x86, 0xca, 0x30, 0x16, 0x82, 0xba,
	0xb8, 0x45, 0x95, 0x13, 0x0f, 0xcd, 0xbf, 0xa6, 0xa1, 0xf4, 0xd8, 0xfd, 0x54, 0x16, 0x52, 0x40,
	0x37, 0x24, 0xf4, 0x0b, 0x08, 0x3b, 0x32, 0x3c, 0x76, 0x9f, 0x0a, 0x29, 0x74, 0x3c, 0x0a, 0x8e,
	0xd7, 0x63, 0x54, 0x55, 0xac, 0xaf, 0x46, 0x02, 0xfd, 0xdc, 0x80, 0x29, 0x41, 0x72, 0x6a, 0x80,
	0xd7, 0xa1, 0x40, 0x80, 0x5d, 0xdc, 0x22, 0x1e, 0x38, 0x16, 0x69, 0x4b, 0x81, 0x4a, 0xb9, 0x34,
	0xa7, 0xe4, 0xd2, 0x65, 0x18, 0x67, 0xd8, 0x83, 0x1c, 0x8f, 0x63, 0x98, 0x7f, 0x4c, 0x43, 0x69,
	0x13, 0xfb, 0xce, 0x93, 0x0b, 0x1c, 0x6c, 0x65, 0x18, 0xab, 0xd9, 0x3d, 0x2c, 0xd4, 0xe0, 0x74,
	0xc8, 0x8e, 0xde, 0xac, 0x70, 0xf4, 0x8a, 0x36, 0xcc, 0xc9, 0x36, 0x54, 0x05, 0xf8, 0x6a, 0xd8,
	0xf0, 0x29, 0x4c, 0x09, 0x82, 0x53, 0x13, 0x2e, 0x42, 0xfe, 0x21, 0xfe, 0x54, 0xcd, 0x20, 0x02,
	0x48, 0x32, 0xde, 0x98, 0x62, 0xbc, 0x37, 0x60, 0x94, 0xa0, 0x0e, 0x4a, 0x2e, 0x74, 0xda, 0xbc,
	0x1a, 0xe6, 0xb9, 0x80, 0x19, 0xe4, 0x81, 0xc3, 0xae, 0x0f, 0xcd, 0x43, 0x28, 0x27, 0xa7, 0xa8,
	0x74, 0x0f, 0x60, 0x24, 0x9c, 0xe8, 0x95, 0xd3, 0x8b, 0x99, 0xa5, 0x6c, 0x6d, 0xfd, 0xcb, 0x67,
	0xe7, 0x50, 0x2c, 0x37, 0x3f, 0x21, 0x62, 0x62, 0x59, 0x88, 0x1d, 0xf7, 0xc0, 0x8b, 0x3d, 0xe8,
	0x9b, 0x42, 0x89, 0x76, 0x71, 0x3e, 0x24, 0x53, 0xed, 0xc9, 0x1b, 0x22, 0x6c, 0xe8, 0x86, 0x56,
	0x21, 0x17, 0x4e, 0x84, 0xb0, 0xc8, 0x07, 0xf3, 0xd5, 0xd9, 0x84, 0xb7, 0x46, 0x0b, 0x18, 0x9a,
	0xf9, 0xaf, 0x4c, 0x44, 0x4f, 0xb1, 0x2b, 0x2f, 0x39, 0x3f, 0xdc, 0xff, 0x2e, 0x6e, 0x06, 0x71,
	0xc9, 0x49, 0x46, 0xe8, 0x17, 0x06, 0x14, 0xd9, 0x8a, 0x1e, 0xb1, 0x6d, 0x3a, 0x72, 0xe2, 0xdb,
	0xfc, 0x94, 0xd6, 0xd3, 0x5c, 0x51, 0xd6, 0x5d, 0xb2, 0x7c, 0x50, 0xa8, 0xa1, 0x1f, 0x19, 0x00,
	0x1c, 0x56, 0xce, 0x44, 0x42, 0xbd, 0x7d, 0x0e, 0xa1, 0x2e, 0x27, 0x8f, 0xc0, 0xbb, 0x52, 0x83,
	0x19, 0xdd, 0x5e, 0x35, 0xc1, 0x36, 0x23, 0x06, 0xdb, 0x84, 0x58, 0x1c, 0x3c, 0x16, 0xf5, 0xfc,
	0xe2, 0x62, 0xf5, 0xef, 0x19, 0xb8, 0xaa, 0xd1, 0x05, 0xf5, 0xa2, 0x5f, 0x0e, 0xb4, 0xee, 0xfa,
	0x10, 0x45, 0x92, 0xc5, 0x2f, 0xd9, 0xbc, 0x3f, 0x96, 0xcd, 0x9b, 0x8d, 0xa4, 0x5a, 0x3d, 0x8f,
	0x54, 0xff, 0x13, 0xf6, 0xfd, 0x59, 0x1a, 0xca, 0x8d, 0xf3, 0x06, 0xf5, 0xf0, 0xd0, 0x69, 0xfc,
	0x27, 0x43, 0xe7, 0x25, 0xa9, 0x65, 0x0d, 0xae, 0x36, 0x06, 0x7a, 0xfd, 0x00, 0xb5, 0x98, 0x77,
	0x60, 0xe2, 0x81, 0xd7, 0x76, 0x5c, 0xa1, 0xce, 0x6b, 0x04, 0x9e, 0x8f, 0x1d, 0x56, 0xe7, 0xd1,
	0x61, 0x28, 0x62, 0x9d, 0x5d, 0x85, 0x86, 0x3f, 0xcd, 0xeb, 0x30, 0x49, 0xd7, 0xf2, 0x9a, 0xb2,
	0xee, 0xb8, 0xfb, 0x1d, 0x6f, 0x9f, 0x16, 0x03, 0xf1, 0xd0, 0x2c, 0x46, 0xa8, 0x5e, 0x9f, 0x1d,
	0x5c, 0x25, 0x28, 0xc4, 0x00, 0xfa, 0xdd, 0xfd, 0x3c, 0x0d, 0xe3, 0x2c, 0x8d, 0xa3, 0x47, 0xc2,
	0x80, 0xa8, 0xe5, 0xc2, 0x07, 0x8b, 0x40, 0x75, 0x11, 0xa0, 0x6e, 0xfb, 0xf6, 0x31, 0x0e, 0xb0,
	0x5f, 0x23, 0x5b, 0xd9, 0x4e, 0x59, 0x02, 0x0c, 0xdd, 0x83, 0x92, 0xd5, 0xb8, 0xf7, 0xe1, 0xbd,
	0xad, 0x3a, 0x03, 0xd2, 0xb3, 0x66, 0x3a, 0xb6, 0x00, 0x9f, 0x3f, 0xde, 0x4e, 0x59, 0x09, 0x74,
	0xf4, 0x0d, 0x28, 0x5a, 0x8d, 0x7b, 0xf5, 0x46, 0x83, 0x53, 0x20, 0xe5, 0x39, 0x12, 0x28, 0x90,
	0xe9, 0x90, 0x80, 0x8a, 0x8c, 0xf6, 0x60, 0x66, 0x6b, 0x63, 0x73, 0x7b, 0x95, 0xd4, 0x1b, 0x9c,
	0x08, 0x29, 0x9b, 0xaf, 0xc4, 0x44, 0x64, 0x9c, 0x90, 0x92, 0x76, 0x59, 0x2d, 0x0f, 0xe3, 0x6c,
	0x60, 0x62, 0x98, 0x94, 0x8e, 0x4a, 0xb4, 0x00, 0xb0, 0xe7, 0xb8, 0xbb, 0xf8, 0xa4, 0xe1, 0x3c,
	0xc5, 0xd4, 0xff, 0x04, 0x48, 0x34, 0x6f, 0x7f, 0x16, 0xcf, 0xa7, 0xe9, 0x3c, 0x83, 0x84, 0xc1,
	0x7f, 0xbf, 0x63, 0xb7, 0x7b, 0x91, 0x92, 0xb2, 0x16, 0x19, 0x98, 0x3f, 0x34, 0x20, 0xff, 0x41,
	0x24, 0xe6, 0x96, 0xef, 0x7b, 0x3e, 0xfa, 0x00, 0xb2, 0x1b, 0x5e, 0x8b, 0xd2, 0xaf, 0xad, 0x7d,
	0xf9, 0xec, 0xda, 0xcd, 0x33, 0x1b, 0xd2, 0xc2, 0x41, 0xdf, 0x77, 0xad, 0x88, 0x40, 0xf4, 0x7e,
	0x86, 0x03, 0xdb, 0xe9, 0x44, 0xa2, 0x8c, 0x5b, 0x74, 0x14, 0x8a, 0x61, 0xe1, 0xc0, 0x27, 0xb5,
	0x69, 0xce, 0x22, 0x03, 0xf3, 0x37, 0x19, 0xc8, 0x0b, 0xd6, 0x42, 0x16, 0xe4, 0xb6, 0xed, 0xde,
	0x21, 0x2b, 0x77, 0x2f, 0xee, 0x53, 0x8c, 0x0e, 0xba, 0x01, 0x99, 0xbd, 0xf6, 0x41, 0x24, 0x4e,
	0xa1, 0x5a, 0xd6, 0xf8, 0xc8, 0xca, 0x9e, 0xdd, 0x3b, 0xb2, 0x42, 0x24, 0xb4, 0x0d, 0xa5, 0x2d,
	0xb7, 0xe9, 0xb5, 0x1c, 0xb7, 0x1d, 0xce, 0x3c, 0x3a, 0xe9, 0x92, 0x0b, 0xbd, 0x42, 0x75, 0x5e,
	0xb7, 0x30, 0xc6, 0xb1, 0x12, 0xab, 0xc2, 0xef, 0x5b, 0x11, 0x46, 0xc3, 0x4d, 0x82, 0x99, 0x01,
	0x64, 0x43, 0xd6, 0xa8, 0x08, 0xf9, 0x8d, 0xa3, 0xf6, 0x5e, 0xfb, 0x60, 0xf5, 0xa1, 0xe7, 0xe2,
	0x52, 0x4a, 0x00, 0x34, 0x0e, 0xed, 0xd5, 0x92, 0x81, 0xa6, 0x60, 0x92, 0x03, 0xaa, 0xb7, 0xd7,
	0x4b, 0x69, 0x19, 0xb4, 0xf6, 0xee, 0xad, 0x52, 0x46, 0x06, 0xdd, 0x5e, 0xad, 0x96, 0xb2, 0xca,
	0xc2, 0xea, 0xad, 0xd2, 0x88, 0xf9, 0x1e, 0xe4, 0x98, 0x94, 0x73, 0x80, 0x36, 0x8e, 0x9e, 0x3e,
	0xf4, 0xc2, 0x4f, 0x82, 0x46, 0x17, 0x37, 0x9d, 0x03, 0x07, 0xb7, 0x4a, 0x29, 0x34, 0x0b, 0x53,
	0x1b, 0x47, 0x4f, 0x05, 0x68, 0x08, 0x36, 0xcc, 0x5f, 0xa7, 0x01, 0x78, 0x68, 0xbc, 0x14, 0x6b,
	0x5d, 0x17, 0xad, 0x75, 0x25, 0x19, 0x8f, 0x82, 0xb1, 0xfe, 0x0f, 0x26, 0x1b, 0x76, 0x27, 0x08,
	0x8f, 0xbe, 0x0d, 0xaf, 0xef, 0x06, 0xd4, 0xc3, 0x65, 0xe0, 0x7f, 0x49, 0xc9, 0x7f, 0x4e, 0x43,
	0x51, 0x89, 0x7f, 0x74, 0x17, 0x32, 0xbb, 0xad, 0x83, 0x48, 0x53, 0x85, 0xea, 0xf2, 0x80, 0x2c,
	0x11, 0x7e, 0x5b, 0x44, 0x23, 0x3b, 0x70, 0x3c, 0xf7, 0x7e, 0xdf, 0x6d, 0x86, 0x7f, 0xad, 0x70,
	0x65, 0x18, 0xea, 0x8d, 0x43, 0xdb, 0xc7, 0x2d, 0xe1, 0x06, 0x5a, 0x80, 0x84, 0xf3, 0xf5, 0xfe,
	0x7e, 0xc7, 0x69, 0x0a, 0x17, 0xad, 0x02, 0xc4, 0xfc, 0xad, 0x01, 0xb3, 0x5a, 0xf2, 0x44, 0x17,
	0xad, 0x87, 0x5e, 0xf0, 0xb8, 0x87, 0x5b, 0x6f, 0x97, 0x52, 0x28, 0x0f, 0x63, 0x21, 0xa0, 0xdf,
	0xe9, 0x94, 0x0c, 0x54, 0x00, 0xd8, 0x38, 0x6a, 0x85, 0x5a, 0xda, 0x6d, 0x1d, 0x94, 0xd2, 0x32,
	0xf6, 0x5a, 0x29, 0x23, 0x03, 0x6e, 0x95, 0xb2, 0xa8, 0x04, 0x13, 0x64, 0x45, 0xb5, 0x7a, 0x2b,
	0x5c, 0x33, 0x22, 0x40, 0x6e, 0xaf, 0x87, 0x90, 0x51, 0x0e, 0x59, 0x7b, 0x37, 0xc2, 0x19, 0xe3,
	0x90, 0xdb, 0xab, 0xd5, 0x10, 0x92, 0x33, 0xbf, 0x06, 0xc5, 0xed, 0xbd, 0x7b, 0x1b, 0xe4, 0x12,
	0xa9, 0x13, 0x69, 0x71, 0x09, 0x8a, 0x24, 0xe1, 0x70, 0xbb, 0x87, 0x1a, 0x9d, 0xb4, 0x54, 0xb0,
	0xb9, 0x0e, 0x33, 0x16, 0xa6, 0x1f, 0xf5, 0xd1, 0xe7, 0x1a, 0x3d, 0x41, 0x17, 0x00, 0xe8, 0xd5,
	0x08, 0xbf, 0xd5, 0x11, 0x20, 0xe6, 0x01, 0xcc, 0x2a, 0xeb, 0xf8, 0x9d, 0x15, 0x99, 0x90, 0x96,
	0x4a, 0x30, 0x74, 0x1d, 0xc6, 0xe8, 0x32, 0x5a, 0x17, 0x24, 0x6f, 0xa4, 0xe8, 0x0f, 0xf3, 0x0f,
	0x06, 0x14, 0xe4, 0x62, 0x00, 0xbd, 0x2d, 0x94, 0x40, 0x35, 0x42, 0xbf, 0x56, 0xf8, 0xe2, 0xd9,
	0x35, 0x01, 0x1a, 0x1e, 0x87, 0x7c, 0x84, 0xd6, 0x20, 0xcf, 0x46, 0x8f, 0xee, 0x47, 0x3c, 0x73,
	0xb5, 0xe2, 0x17, 0xcf, 0xae, 0x89, 0xe0, 0xed, 0x94, 0x25, 0x0e, 0x25, 0x36, 0x3b, 0x91, 0xa3,
	0x64, 0x14, 0x36, 0x3b, 0x12, 0x9b, 0x9d, 0x1a, 0x40, 0xce, 0x73, 0xf1, 0x77, 0xec, 0x20, 0xf0,
	0xcd, 0x3f, 0xa5, 0xd9, 0x1e, 0xd1, 0x3c, 0x8c, 0xd3, 0x9f, 0x3b, 0x9b, 0x54, 0x1f, 0x1c, 0x10,
	0x96, 0x1b, 0x1f, 0x61, 0xbf, 0xe7, 0x78, 0xa4, 0x2a, 0xc9, 0x58, 0xf1, 0x10, 0x21, 0xc8, 0x3e,
	0xfa, 0x6c, 0x67, 0x33, 0x7e, 0x0d, 0x08, 0x7f, 0xa3, 0x4f, 0x35, 0xb5, 0xf5, 0x35, 0x45, 0x7b,
	0x2f, 0xa3, 0xdc, 0x8b, 0x2f, 0xca, 0x3b, 0xde, 0x7e, 0xaf, 0x3c, 0xb2, 0x98, 0x89, 0x2f, 0xca,
	0xc3, 0xf1, 0x4b, 0x2a, 0x05, 0xab, 0xbf, 0x9b, 0x83, 0xd1, 0x0d, 0xff, 0xa4, 0x1b, 0x78, 0xe8,
	0x5b, 0x50, 0x90, 0xbb, 0xa0, 0xd0, 0xab, 0xea, 0x55, 0xb3, 0xd4, 0x48, 0x55, 0x59, 0x18, 0x34,
	0x4d, 0xeb, 0xb4, 0x14, 0xda, 0x02, 0xe0, 0x0d, 0x4f, 0xe8, 0x2a, 0xbb, 0xd8, 0x51, 0x1b, 0xa8,
	0x2a, 0x15, 0xdd, 0x14, 0x23, 0xf3, 0x5e, 0xdc, 0x0b, 0x83, 0x66, 0x65, 0xbc, 0x78, 0xf9, 0x9c,
	0x0a, 0x66, 0x4b, 0x77, 0x61, 0x42, 0x6c, 0x50, 0x42, 0xaf, 0xc8, 0x98, 0xd2, 0xbb, 0x67, 0x65,
	0x5e, 0x3f, 0xc9, 0x88, 0xd5, 0x60, 0x9c, 0xf5, 0x20, 0xa1, 0xb2, 0x8c, 0xcc, 0xaf, 0xa9, 0x2a,
	0x57, 0x35, 0x33, 0x8c, 0xc6, 0x36, 0xe4, 0x85, 0x86, 0x23, 0xa4, 0x6c, 0x5c, 0x7c, 0xbb, 0xac,
	0xbc, 0xa2, 0x9d, 0x4b, 0x6e, 0x8d, 0x3c, 0x4b, 0xa9, 0x5b, 0x93, 0x1e, 0xcd, 0xd4, 0xad, 0x29,
	0x2f, 0x59, 0x91, 0x58, 0x42, 0x1f, 0x10, 0x17, 0x2b, 0xd9, 0x6b, 0xc4, 0xc5, 0xd2, 0x34, 0x0e,
	0xd1, 0x0d, 0x62, 0x0d, 0xa5, 0x64, 0xe7, 0x90, 0xb0, 0x41, 0xac, 0xa3, 0xf4, 0x10, 0x26, 0xa5,
	0x76, 0x1d, 0x34, 0xaf, 0x70, 0x96, 0xad, 0xf7, 0xea, 0x80, 0x59, 0x91, 0x9e, 0xd4, 0x69, 0xc3,
	0xe9, 0xe9, 0x5a, 0x79, 0x38, 0x3d, 0x6d, 0x7b, 0x8e, 0x99, 0x42, 0xef, 0xc3, 0x18, 0x65, 0x85,
	0xe6, 0x14, 0xde, 0x31, 0x8d, 0x2b, 0x09, 0xb8, 0xb8, 0x9a, 0x12, 0xe6, 0xab, 0xe5, 0xb6, 0x1a,
	0xbe, 0x5a, 0x69, 0x95, 0x21, 0xc6, 0x17, 0x3b, 0x5d, 0x90, 0x6a, 0x14, 0xc9, 0x91, 0xe6, 0xf5,
	0x93, 0x92, 0x27, 0x61, 0x1d, 0x31, 0x4d, 0x63, 0x4c, 0x65, 0x5e, 0x3f, 0xa9, 0xb1, 0x1a, 0xf5,
	0x4b, 0x95, 0xbb, 0xec, 0x98, 0xaf, 0x0e, 0x98, 0xd5, 0x58, 0x4d, 0xa5, 0xa7, 0xeb, 0x5f, 0x49,
	0x58, 0x2d, 0x41, 0xef, 0x2e, 0xe4, 0xe2, 0x46, 0x10, 0xc4, 0x14, 0xac, 0xb4, 0x9b, 0x54, 0xca,
	0xc9, 0x09, 0x31, 0xa9, 0xf1, 0x5e, 0x0e, 0x9e, 0xd4, 0x12, 0x3d, 0x23, 0x3c, 0xa9, 0x25, 0x5b,
	0x3f, 0x08, 0x19, 0xde, 0xa7, 0xc1, 0xc9, 0x24, 0x5a, 0x3f, 0x38, 0x99, 0x64, 0x5b, 0x07, 0xb1,
	0x9d, 0xd8, 0x81, 0xc1, 0x6d, 0xa7, 0x69, 0xec, 0xe0, 0xb6, 0xd3, 0x35, 0x6d, 0x90, 0x04, 0xc7,
	0xda, 0x2e, 0x90, 0xa4, 0x03, 0xc9, 0x05, 0xae, 0x6a, 0x66, 0xc4, 0xf8, 0x17, 0xba, 0x27, 0x90,
	0xa2, 0x04, 0x7d, 0x82, 0xd3, 0xb5, 0x5b, 0xa4, 0xd0, 0x1a, 0x64, 0x43, 0x06, 0x68, 0x5a, 0x64,
	0x17, 0xaf, 0x9d, 0x91, 0x81, 0xe2, 0x59, 0x41, 0xa8, 0xf1, 0xb3, 0x42, 0x6a, 0xa7, 0xe0, 0x67,
	0x85, 0xd2, 0x0c, 0xc1, 0x2c, 0x42, 0xdd, 0x4c, 0xda, 0xa4, 0xec, 0x63, 0x15, 0xdd, 0x54, 0xd2,
	0x22, 0x6a, 0x5e, 0xd6, 0x34, 0x33, 0xa8, 0x16, 0xd1, 0xe5, 0x65, 0xe1, 0xe5, 0x92, 0x6b, 0x33,
	0xd9, 0x22, 0xc0, 0xb5, 0xa9, 0x79, 0x83, 0x37, 0x53, 0xe8, 0x11, 0x14, 0x95, 0x37, 0x50, 0xb4,
	0x30, 0xfc, 0x29, 0xb9, 0x72, 0x6d, 0xe0, 0xbc, 0x98, 0xc5, 0xe8, 0x7b, 0x21, 0xcf, 0x62, 0xf2,
	0xab, 0x25, 0xcf, 0x62, 0xca, 0xc3, 0x22, 0xf1, 0x37, 0xf6, 0xdc, 0xc5, 0xfd, 0x4d, 0x7d, 0xbb,
	0xe3, 0xfe, 0x96, 0x78, 0x1b, 0xa3, 0x87, 0x72, 0xfc, 0xde, 0x22, 0x1c, 0xca, 0xca, 0xdb, 0x91,
	0x70, 0x28, 0xab, 0x8f, 0x33, 0x66, 0x0a, 0x7d, 0x0c, 0x25, 0xf5, 0x71, 0x04, 0x09, 0x9b, 0xd7,
	0xbe, 0xa8, 0x54, 0x16, 0x07, 0x23, 0x0c, 0x22, 0x1c, 0x5d, 0xa4, 0x68, 0x09, 0x0b, 0xaf, 0x24,
	0x7a, 0xc2, 0xe2, 0xfb, 0x86, 0x99, 0x42, 0x9f, 0xc0, 0x54, 0xe2, 0x96, 0x17, 0x2d, 0x9e, 0x76,
	0xbf, 0x5f, 0x79, 0xed, 0xd4, 0x2b, 0x62, 0x42, 0xbb, 0x31, 0x98, 0x76, 0xe3, 0x54, 0xda, 0x8d,
	0x21, 0xb4, 0xd7, 0x61, 0x24, 0xba, 0x09, 0x44, 0x2c, 0x7e, 0xc5, 0x4b, 0xc5, 0xca, 0xac, 0x02,
	0x15, 0xc3, 0x9a, 0xdc, 0x02, 0x22, 0x11, 0x85, 0x5f, 0x13, 0xf2, 0xb0, 0x56, 0x2e, 0x0b, 0xa3,
	0x03, 0x44, 0xfa, 0x8c, 0xe2, 0x07, 0x88, 0xee, 0xab, 0x8c, 0x1f, 0x20, 0xda, 0x6f, 0x2f, 0x33,
	0x55, 0x7b, 0xe7, 0x2f, 0xcf, 0x17, 0x8c, 0xbf, 0x3d, 0x5f, 0x30, 0xfe, 0xf9, 0x7c, 0xc1, 0x80,
	0x4a, 0xd3, 0x3b, 0x5e, 0x71, 0xf6, 0x8f, 0x57, 0xa2, 0xd3, 0xc6, 0x8b, 0x17, 0xb7, 0xfd, 0x6e,
	0xb3, 0x96, 0x27, 0x95, 0x75, 0xdd, 0xf7, 0x02, 0xaf, 0x6e, 0xec, 0x8f, 0x46, 0xff, 0x98, 0xb0,
	0xf6, 0xef, 0x00, 0x00, 0x00, 0xff, 0xff, 0xfa, 0x03, 0xff, 0xd1, 0xbc, 0x30, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// CryptoClient is the client API for Crypto service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CryptoClient interface {
	// CK_RV m_GenerateRandom (
	//     CK_BYTE_PTR rnd, CK_ULONG rndlen,
	//     target_t target) ;
	GenerateRandom(ctx context.Context, in *GenerateRandomRequest, opts ...grpc.CallOption) (*GenerateRandomResponse, error)
	// CK_RV m_DigestInit (
	//     unsigned char *state, size_t *statelen,
	//     const CK_MECHANISM_PTR mech,
	//     target_t target) ;
	DigestInit(ctx context.Context, in *DigestInitRequest, opts ...grpc.CallOption) (*DigestInitResponse, error)
	// CK_RV m_Digest (
	//     const unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR data, CK_ULONG datalen,
	//     CK_BYTE_PTR digest, CK_ULONG_PTR digestlen,
	//     target_t target) ;
	Digest(ctx context.Context, in *DigestRequest, opts ...grpc.CallOption) (*DigestResponse, error)
	// CK_RV m_DigestUpdate (
	//     unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR data, CK_ULONG datalen,
	//     target_t target) ;
	DigestUpdate(ctx context.Context, in *DigestUpdateRequest, opts ...grpc.CallOption) (*DigestUpdateResponse, error)
	// CK_RV m_DigestKey (
	//     unsigned char *state, size_t statelen,
	//     const unsigned char *key, size_t keylen,
	//     target_t target) ;
	DigestKey(ctx context.Context, in *DigestKeyRequest, opts ...grpc.CallOption) (*DigestKeyResponse, error)
	// CK_RV m_DigestFinal (
	//     const unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR digest, CK_ULONG_PTR digestlen,
	//     target_t target) ;
	DigestFinal(ctx context.Context, in *DigestFinalRequest, opts ...grpc.CallOption) (*DigestFinalResponse, error)
	// CK_RV m_DigestSingle (
	//     CK_MECHANISM_PTR mech,
	//     CK_BYTE_PTR data, CK_ULONG datalen,
	//     CK_BYTE_PTR digest, CK_ULONG_PTR digestlen,
	//     target_t target) ;
	DigestSingle(ctx context.Context, in *DigestSingleRequest, opts ...grpc.CallOption) (*DigestSingleResponse, error)
	// CK_RV m_EncryptInit (
	//     unsigned char *state, size_t *statelen,
	//     CK_MECHANISM_PTR mech,
	//     const unsigned char *key, size_t keylen,
	//     target_t target) ;
	EncryptInit(ctx context.Context, in *EncryptInitRequest, opts ...grpc.CallOption) (*EncryptInitResponse, error)
	// CK_RV m_DecryptInit (
	//     unsigned char *state, size_t *statelen,
	//     CK_MECHANISM_PTR mech,
	//     const unsigned char *key, size_t keylen,
	//     target_t target) ;
	DecryptInit(ctx context.Context, in *DecryptInitRequest, opts ...grpc.CallOption) (*DecryptInitResponse, error)
	// CK_RV m_EncryptUpdate (
	//     unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR plain, CK_ULONG plainlen,
	//     CK_BYTE_PTR ciphered, CK_ULONG_PTR cipheredlen,
	//     target_t target) ;
	EncryptUpdate(ctx context.Context, in *EncryptUpdateRequest, opts ...grpc.CallOption) (*EncryptUpdateResponse, error)
	// CK_RV m_DecryptUpdate (
	//     unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR ciphered, CK_ULONG cipheredlen,
	//     CK_BYTE_PTR plain, CK_ULONG_PTR plainlen,
	//     target_t target) ;
	DecryptUpdate(ctx context.Context, in *DecryptUpdateRequest, opts ...grpc.CallOption) (*DecryptUpdateResponse, error)
	// CK_RV m_Encrypt (
	//     const unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR plain, CK_ULONG plainlen,
	//     CK_BYTE_PTR ciphered, CK_ULONG_PTR cipheredlen,
	//     target_t target) ;
	Encrypt(ctx context.Context, in *EncryptRequest, opts ...grpc.CallOption) (*EncryptResponse, error)
	// CK_RV m_Decrypt (
	//     const unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR ciphered, CK_ULONG cipheredlen,
	//     CK_BYTE_PTR plain, CK_ULONG_PTR plainlen,
	//     target_t target) ;
	Decrypt(ctx context.Context, in *DecryptRequest, opts ...grpc.CallOption) (*DecryptResponse, error)
	// CK_RV m_EncryptFinal (
	//     const unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR ciphered, CK_ULONG_PTR cipheredlen,
	//     target_t target) ;
	EncryptFinal(ctx context.Context, in *EncryptFinalRequest, opts ...grpc.CallOption) (*EncryptFinalResponse, error)
	// CK_RV m_DecryptFinal (
	//     const unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR plain, CK_ULONG_PTR plainlen,
	//     target_t target) ;
	DecryptFinal(ctx context.Context, in *DecryptFinalRequest, opts ...grpc.CallOption) (*DecryptFinalResponse, error)
	// CK_RV m_EncryptSingle (
	//     const unsigned char *key, size_t keylen,
	//     CK_MECHANISM_PTR mech,
	//     CK_BYTE_PTR plain, CK_ULONG plainlen,
	//     CK_BYTE_PTR ciphered, CK_ULONG_PTR cipheredlen,
	//     target_t target) ;
	EncryptSingle(ctx context.Context, in *EncryptSingleRequest, opts ...grpc.CallOption) (*EncryptSingleResponse, error)
	// CK_RV m_DecryptSingle (
	//     const unsigned char *key, size_t keylen,
	//     CK_MECHANISM_PTR mech,
	//     CK_BYTE_PTR ciphered, CK_ULONG cipheredlen,
	//     CK_BYTE_PTR plain, CK_ULONG_PTR plainlen,
	//     target_t target) ;
	DecryptSingle(ctx context.Context, in *DecryptSingleRequest, opts ...grpc.CallOption) (*DecryptSingleResponse, error)
	// CK_RV m_SignInit (
	//     unsigned char *state, size_t *statelen,
	//     CK_MECHANISM_PTR mech,
	//     const unsigned char *privKey, size_t privKeylen,
	//     target_t target) ;
	SignInit(ctx context.Context, in *SignInitRequest, opts ...grpc.CallOption) (*SignInitResponse, error)
	// CK_RV m_VerifyInit (
	//     unsigned char *state, size_t *statelen,
	//     CK_MECHANISM_PTR mech,
	//     const unsigned char *pubKey, size_t pubKeylen,
	//     target_t target) ;
	VerifyInit(ctx context.Context, in *VerifyInitRequest, opts ...grpc.CallOption) (*VerifyInitResponse, error)
	// CK_RV m_SignUpdate (
	//     unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR data, CK_ULONG datalen,
	//     target_t target) ;
	SignUpdate(ctx context.Context, in *SignUpdateRequest, opts ...grpc.CallOption) (*SignUpdateResponse, error)
	// CK_RV m_VerifyUpdate (
	//     unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR data, CK_ULONG datalen,
	//     target_t target) ;
	VerifyUpdate(ctx context.Context, in *VerifyUpdateRequest, opts ...grpc.CallOption) (*VerifyUpdateResponse, error)
	// CK_RV m_SignFinal (
	//     const unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR signature, CK_ULONG_PTR signaturelen,
	//     target_t target) ;
	SignFinal(ctx context.Context, in *SignFinalRequest, opts ...grpc.CallOption) (*SignFinalResponse, error)
	// CK_RV m_VerifyFinal (
	//     const unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR signature, CK_ULONG signaturelen,
	//     target_t target) ;
	VerifyFinal(ctx context.Context, in *VerifyFinalRequest, opts ...grpc.CallOption) (*VerifyFinalResponse, error)
	// CK_RV m_Sign (
	//     const unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR data, CK_ULONG datalen,
	//     CK_BYTE_PTR signature, CK_ULONG_PTR signaturelen,
	//     target_t target) ;
	Sign(ctx context.Context, in *SignRequest, opts ...grpc.CallOption) (*SignResponse, error)
	// CK_RV m_Verify (
	//     const unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR data, CK_ULONG datalen,
	//     CK_BYTE_PTR signature, CK_ULONG signaturelen,
	//     target_t target) ;
	Verify(ctx context.Context, in *VerifyRequest, opts ...grpc.CallOption) (*VerifyResponse, error)
	// CK_RV m_SignSingle (
	//     const unsigned char *privKey, size_t privKeylen,
	//     CK_MECHANISM_PTR mech,
	//     CK_BYTE_PTR data, CK_ULONG datalen,
	//     CK_BYTE_PTR signature, CK_ULONG_PTR signaturelen,
	//     target_t target) ;
	SignSingle(ctx context.Context, in *SignSingleRequest, opts ...grpc.CallOption) (*SignSingleResponse, error)
	// CK_RV m_VerifySingle (
	//     const unsigned char *pubKey, size_t pubKeylen,
	//     CK_MECHANISM_PTR mech,
	//     CK_BYTE_PTR data, CK_ULONG datalen,
	//     CK_BYTE_PTR signature, CK_ULONG signaturelen,
	//     target_t target) ;
	VerifySingle(ctx context.Context, in *VerifySingleRequest, opts ...grpc.CallOption) (*VerifySingleResponse, error)
	// CK_RV m_GenerateKey (
	//     CK_MECHANISM_PTR mech,
	//     CK_ATTRIBUTE_PTR templateBytes, CK_ULONG templateByteslen,
	//     const unsigned char *pin, size_t pinlen,
	//     unsigned char *keyBytes, size_t *keyByteslen,
	//     unsigned char *checkSum, size_t *checkSumlen,
	//     target_t target) ;
	GenerateKey(ctx context.Context, in *GenerateKeyRequest, opts ...grpc.CallOption) (*GenerateKeyResponse, error)
	// CK_RV m_GenerateKeyPair (
	//     CK_MECHANISM_PTR mech,
	//     CK_ATTRIBUTE_PTR pubKeyTemplateBytes, CK_ULONG pubKeyTemplateByteslen,
	//     CK_ATTRIBUTE_PTR privKeyTemplateBytes, CK_ULONG privKeyTemplateByteslen,
	//     const unsigned char *pin, size_t pinlen,
	//     unsigned char *privKeyBytes, size_t *privKeyByteslen,
	//     unsigned char *pubKeyBytes, size_t *pubKeyByteslen,
	//     target_t target) ;
	GenerateKeyPair(ctx context.Context, in *GenerateKeyPairRequest, opts ...grpc.CallOption) (*GenerateKeyPairResponse, error)
	// CK_RV m_WrapKey (
	//     const unsigned char *key, size_t keylen,
	//     const unsigned char *keK, size_t keKlen,
	//     const unsigned char *macKey, size_t macKeylen,
	//     const CK_MECHANISM_PTR mech,
	//     CK_BYTE_PTR wrapped, CK_ULONG_PTR wrappedlen,
	//     target_t target) ;
	WrapKey(ctx context.Context, in *WrapKeyRequest, opts ...grpc.CallOption) (*WrapKeyResponse, error)
	// CK_RV m_UnwrapKey (
	//     const CK_BYTE_PTR wrapped, CK_ULONG wrappedlen,
	//     const unsigned char *keK, size_t keKlen,
	//     const unsigned char *macKey, size_t macKeylen,
	//     const unsigned char *pin, size_t pinlen,
	//     const CK_MECHANISM_PTR mech,
	//     const CK_ATTRIBUTE_PTR templateBytes, CK_ULONG templateByteslen,
	//     unsigned char *unwrappedBytes, size_t *unwrappedByteslen,
	//     CK_BYTE_PTR checkSum, CK_ULONG *checkSumlen,
	//     target_t target) ;
	UnwrapKey(ctx context.Context, in *UnwrapKeyRequest, opts ...grpc.CallOption) (*UnwrapKeyResponse, error)
	// CK_RV m_DeriveKey (
	//     CK_MECHANISM_PTR mech,
	//     CK_ATTRIBUTE_PTR templateBytes, CK_ULONG templateByteslen,
	//     const unsigned char *baseKey, size_t baseKeylen,
	//     const unsigned char *data, size_t datalen,
	//     const unsigned char *pin, size_t pinlen,
	//     unsigned char *newKeyBytes, size_t *newKeyByteslen,
	//     unsigned char *checkSum, size_t *checkSumlen,
	//     target_t target) ;
	DeriveKey(ctx context.Context, in *DeriveKeyRequest, opts ...grpc.CallOption) (*DeriveKeyResponse, error)
	// CK_RV m_GetMechanismList (
	//     CK_SLOT_ID slot,
	//     CK_MECHANISM_TYPE_PTR mechs, CK_ULONG_PTR mechslen,
	//     target_t target) ;
	GetMechanismList(ctx context.Context, in *GetMechanismListRequest, opts ...grpc.CallOption) (*GetMechanismListResponse, error)
	// CK_RV m_GetMechanismInfo (
	//     CK_SLOT_ID slot,
	//     CK_MECHANISM_TYPE mech,
	//     CK_MECHANISM_INFO_PTR mechInfo,
	//     target_t target) ;
	GetMechanismInfo(ctx context.Context, in *GetMechanismInfoRequest, opts ...grpc.CallOption) (*GetMechanismInfoResponse, error)
	// CK_RV m_GetAttributeValue (
	//     const unsigned char *object, size_t objectlen,
	//     CK_ATTRIBUTE_PTR attributesBytes, CK_ULONG attributesByteslen,
	//     target_t target) ;
	GetAttributeValue(ctx context.Context, in *GetAttributeValueRequest, opts ...grpc.CallOption) (*GetAttributeValueResponse, error)
	// CK_RV m_SetAttributeValue (
	//     unsigned char *object, size_t objectlen,
	//     CK_ATTRIBUTE_PTR attributesBytes, CK_ULONG attributesByteslen,
	//     target_t target) ;
	SetAttributeValue(ctx context.Context, in *SetAttributeValueRequest, opts ...grpc.CallOption) (*SetAttributeValueResponse, error)
	// CK_RV m_Login (
	//     CK_UTF8CHAR_PTR pin, CK_ULONG pinLen,
	//     const unsigned char *nonce, size_t noncelen,
	//     unsigned char *pinblob, size_t *pinbloblen,
	//     target_t target) ;
	Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error)
	// CK_RV m_Logout (
	//     const unsigned char *pinblob, size_t pinbloblen,
	//     target_t target) ;
	Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*LogoutResponse, error)
	RewrapKeyBlob(ctx context.Context, in *RewrapKeyBlobRequest, opts ...grpc.CallOption) (*RewrapKeyBlobResponse, error)
}

type cryptoClient struct {
	cc *grpc.ClientConn
}

func NewCryptoClient(cc *grpc.ClientConn) CryptoClient {
	return &cryptoClient{cc}
}

func (c *cryptoClient) GenerateRandom(ctx context.Context, in *GenerateRandomRequest, opts ...grpc.CallOption) (*GenerateRandomResponse, error) {
	out := new(GenerateRandomResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/GenerateRandom", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) DigestInit(ctx context.Context, in *DigestInitRequest, opts ...grpc.CallOption) (*DigestInitResponse, error) {
	out := new(DigestInitResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/DigestInit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) Digest(ctx context.Context, in *DigestRequest, opts ...grpc.CallOption) (*DigestResponse, error) {
	out := new(DigestResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/Digest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) DigestUpdate(ctx context.Context, in *DigestUpdateRequest, opts ...grpc.CallOption) (*DigestUpdateResponse, error) {
	out := new(DigestUpdateResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/DigestUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) DigestKey(ctx context.Context, in *DigestKeyRequest, opts ...grpc.CallOption) (*DigestKeyResponse, error) {
	out := new(DigestKeyResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/DigestKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) DigestFinal(ctx context.Context, in *DigestFinalRequest, opts ...grpc.CallOption) (*DigestFinalResponse, error) {
	out := new(DigestFinalResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/DigestFinal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) DigestSingle(ctx context.Context, in *DigestSingleRequest, opts ...grpc.CallOption) (*DigestSingleResponse, error) {
	out := new(DigestSingleResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/DigestSingle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) EncryptInit(ctx context.Context, in *EncryptInitRequest, opts ...grpc.CallOption) (*EncryptInitResponse, error) {
	out := new(EncryptInitResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/EncryptInit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) DecryptInit(ctx context.Context, in *DecryptInitRequest, opts ...grpc.CallOption) (*DecryptInitResponse, error) {
	out := new(DecryptInitResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/DecryptInit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) EncryptUpdate(ctx context.Context, in *EncryptUpdateRequest, opts ...grpc.CallOption) (*EncryptUpdateResponse, error) {
	out := new(EncryptUpdateResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/EncryptUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) DecryptUpdate(ctx context.Context, in *DecryptUpdateRequest, opts ...grpc.CallOption) (*DecryptUpdateResponse, error) {
	out := new(DecryptUpdateResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/DecryptUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) Encrypt(ctx context.Context, in *EncryptRequest, opts ...grpc.CallOption) (*EncryptResponse, error) {
	out := new(EncryptResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/Encrypt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) Decrypt(ctx context.Context, in *DecryptRequest, opts ...grpc.CallOption) (*DecryptResponse, error) {
	out := new(DecryptResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/Decrypt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) EncryptFinal(ctx context.Context, in *EncryptFinalRequest, opts ...grpc.CallOption) (*EncryptFinalResponse, error) {
	out := new(EncryptFinalResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/EncryptFinal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) DecryptFinal(ctx context.Context, in *DecryptFinalRequest, opts ...grpc.CallOption) (*DecryptFinalResponse, error) {
	out := new(DecryptFinalResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/DecryptFinal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) EncryptSingle(ctx context.Context, in *EncryptSingleRequest, opts ...grpc.CallOption) (*EncryptSingleResponse, error) {
	out := new(EncryptSingleResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/EncryptSingle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) DecryptSingle(ctx context.Context, in *DecryptSingleRequest, opts ...grpc.CallOption) (*DecryptSingleResponse, error) {
	out := new(DecryptSingleResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/DecryptSingle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) SignInit(ctx context.Context, in *SignInitRequest, opts ...grpc.CallOption) (*SignInitResponse, error) {
	out := new(SignInitResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/SignInit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) VerifyInit(ctx context.Context, in *VerifyInitRequest, opts ...grpc.CallOption) (*VerifyInitResponse, error) {
	out := new(VerifyInitResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/VerifyInit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) SignUpdate(ctx context.Context, in *SignUpdateRequest, opts ...grpc.CallOption) (*SignUpdateResponse, error) {
	out := new(SignUpdateResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/SignUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) VerifyUpdate(ctx context.Context, in *VerifyUpdateRequest, opts ...grpc.CallOption) (*VerifyUpdateResponse, error) {
	out := new(VerifyUpdateResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/VerifyUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) SignFinal(ctx context.Context, in *SignFinalRequest, opts ...grpc.CallOption) (*SignFinalResponse, error) {
	out := new(SignFinalResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/SignFinal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) VerifyFinal(ctx context.Context, in *VerifyFinalRequest, opts ...grpc.CallOption) (*VerifyFinalResponse, error) {
	out := new(VerifyFinalResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/VerifyFinal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) Sign(ctx context.Context, in *SignRequest, opts ...grpc.CallOption) (*SignResponse, error) {
	out := new(SignResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/Sign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) Verify(ctx context.Context, in *VerifyRequest, opts ...grpc.CallOption) (*VerifyResponse, error) {
	out := new(VerifyResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/Verify", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) SignSingle(ctx context.Context, in *SignSingleRequest, opts ...grpc.CallOption) (*SignSingleResponse, error) {
	out := new(SignSingleResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/SignSingle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) VerifySingle(ctx context.Context, in *VerifySingleRequest, opts ...grpc.CallOption) (*VerifySingleResponse, error) {
	out := new(VerifySingleResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/VerifySingle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) GenerateKey(ctx context.Context, in *GenerateKeyRequest, opts ...grpc.CallOption) (*GenerateKeyResponse, error) {
	out := new(GenerateKeyResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/GenerateKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) GenerateKeyPair(ctx context.Context, in *GenerateKeyPairRequest, opts ...grpc.CallOption) (*GenerateKeyPairResponse, error) {
	out := new(GenerateKeyPairResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/GenerateKeyPair", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) WrapKey(ctx context.Context, in *WrapKeyRequest, opts ...grpc.CallOption) (*WrapKeyResponse, error) {
	out := new(WrapKeyResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/WrapKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) UnwrapKey(ctx context.Context, in *UnwrapKeyRequest, opts ...grpc.CallOption) (*UnwrapKeyResponse, error) {
	out := new(UnwrapKeyResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/UnwrapKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) DeriveKey(ctx context.Context, in *DeriveKeyRequest, opts ...grpc.CallOption) (*DeriveKeyResponse, error) {
	out := new(DeriveKeyResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/DeriveKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) GetMechanismList(ctx context.Context, in *GetMechanismListRequest, opts ...grpc.CallOption) (*GetMechanismListResponse, error) {
	out := new(GetMechanismListResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/GetMechanismList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) GetMechanismInfo(ctx context.Context, in *GetMechanismInfoRequest, opts ...grpc.CallOption) (*GetMechanismInfoResponse, error) {
	out := new(GetMechanismInfoResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/GetMechanismInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) GetAttributeValue(ctx context.Context, in *GetAttributeValueRequest, opts ...grpc.CallOption) (*GetAttributeValueResponse, error) {
	out := new(GetAttributeValueResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/GetAttributeValue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) SetAttributeValue(ctx context.Context, in *SetAttributeValueRequest, opts ...grpc.CallOption) (*SetAttributeValueResponse, error) {
	out := new(SetAttributeValueResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/SetAttributeValue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error) {
	out := new(LoginResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/Login", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*LogoutResponse, error) {
	out := new(LogoutResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/Logout", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoClient) RewrapKeyBlob(ctx context.Context, in *RewrapKeyBlobRequest, opts ...grpc.CallOption) (*RewrapKeyBlobResponse, error) {
	out := new(RewrapKeyBlobResponse)
	err := c.cc.Invoke(ctx, "/grep11.Crypto/RewrapKeyBlob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CryptoServer is the server API for Crypto service.
type CryptoServer interface {
	// CK_RV m_GenerateRandom (
	//     CK_BYTE_PTR rnd, CK_ULONG rndlen,
	//     target_t target) ;
	GenerateRandom(context.Context, *GenerateRandomRequest) (*GenerateRandomResponse, error)
	// CK_RV m_DigestInit (
	//     unsigned char *state, size_t *statelen,
	//     const CK_MECHANISM_PTR mech,
	//     target_t target) ;
	DigestInit(context.Context, *DigestInitRequest) (*DigestInitResponse, error)
	// CK_RV m_Digest (
	//     const unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR data, CK_ULONG datalen,
	//     CK_BYTE_PTR digest, CK_ULONG_PTR digestlen,
	//     target_t target) ;
	Digest(context.Context, *DigestRequest) (*DigestResponse, error)
	// CK_RV m_DigestUpdate (
	//     unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR data, CK_ULONG datalen,
	//     target_t target) ;
	DigestUpdate(context.Context, *DigestUpdateRequest) (*DigestUpdateResponse, error)
	// CK_RV m_DigestKey (
	//     unsigned char *state, size_t statelen,
	//     const unsigned char *key, size_t keylen,
	//     target_t target) ;
	DigestKey(context.Context, *DigestKeyRequest) (*DigestKeyResponse, error)
	// CK_RV m_DigestFinal (
	//     const unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR digest, CK_ULONG_PTR digestlen,
	//     target_t target) ;
	DigestFinal(context.Context, *DigestFinalRequest) (*DigestFinalResponse, error)
	// CK_RV m_DigestSingle (
	//     CK_MECHANISM_PTR mech,
	//     CK_BYTE_PTR data, CK_ULONG datalen,
	//     CK_BYTE_PTR digest, CK_ULONG_PTR digestlen,
	//     target_t target) ;
	DigestSingle(context.Context, *DigestSingleRequest) (*DigestSingleResponse, error)
	// CK_RV m_EncryptInit (
	//     unsigned char *state, size_t *statelen,
	//     CK_MECHANISM_PTR mech,
	//     const unsigned char *key, size_t keylen,
	//     target_t target) ;
	EncryptInit(context.Context, *EncryptInitRequest) (*EncryptInitResponse, error)
	// CK_RV m_DecryptInit (
	//     unsigned char *state, size_t *statelen,
	//     CK_MECHANISM_PTR mech,
	//     const unsigned char *key, size_t keylen,
	//     target_t target) ;
	DecryptInit(context.Context, *DecryptInitRequest) (*DecryptInitResponse, error)
	// CK_RV m_EncryptUpdate (
	//     unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR plain, CK_ULONG plainlen,
	//     CK_BYTE_PTR ciphered, CK_ULONG_PTR cipheredlen,
	//     target_t target) ;
	EncryptUpdate(context.Context, *EncryptUpdateRequest) (*EncryptUpdateResponse, error)
	// CK_RV m_DecryptUpdate (
	//     unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR ciphered, CK_ULONG cipheredlen,
	//     CK_BYTE_PTR plain, CK_ULONG_PTR plainlen,
	//     target_t target) ;
	DecryptUpdate(context.Context, *DecryptUpdateRequest) (*DecryptUpdateResponse, error)
	// CK_RV m_Encrypt (
	//     const unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR plain, CK_ULONG plainlen,
	//     CK_BYTE_PTR ciphered, CK_ULONG_PTR cipheredlen,
	//     target_t target) ;
	Encrypt(context.Context, *EncryptRequest) (*EncryptResponse, error)
	// CK_RV m_Decrypt (
	//     const unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR ciphered, CK_ULONG cipheredlen,
	//     CK_BYTE_PTR plain, CK_ULONG_PTR plainlen,
	//     target_t target) ;
	Decrypt(context.Context, *DecryptRequest) (*DecryptResponse, error)
	// CK_RV m_EncryptFinal (
	//     const unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR ciphered, CK_ULONG_PTR cipheredlen,
	//     target_t target) ;
	EncryptFinal(context.Context, *EncryptFinalRequest) (*EncryptFinalResponse, error)
	// CK_RV m_DecryptFinal (
	//     const unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR plain, CK_ULONG_PTR plainlen,
	//     target_t target) ;
	DecryptFinal(context.Context, *DecryptFinalRequest) (*DecryptFinalResponse, error)
	// CK_RV m_EncryptSingle (
	//     const unsigned char *key, size_t keylen,
	//     CK_MECHANISM_PTR mech,
	//     CK_BYTE_PTR plain, CK_ULONG plainlen,
	//     CK_BYTE_PTR ciphered, CK_ULONG_PTR cipheredlen,
	//     target_t target) ;
	EncryptSingle(context.Context, *EncryptSingleRequest) (*EncryptSingleResponse, error)
	// CK_RV m_DecryptSingle (
	//     const unsigned char *key, size_t keylen,
	//     CK_MECHANISM_PTR mech,
	//     CK_BYTE_PTR ciphered, CK_ULONG cipheredlen,
	//     CK_BYTE_PTR plain, CK_ULONG_PTR plainlen,
	//     target_t target) ;
	DecryptSingle(context.Context, *DecryptSingleRequest) (*DecryptSingleResponse, error)
	// CK_RV m_SignInit (
	//     unsigned char *state, size_t *statelen,
	//     CK_MECHANISM_PTR mech,
	//     const unsigned char *privKey, size_t privKeylen,
	//     target_t target) ;
	SignInit(context.Context, *SignInitRequest) (*SignInitResponse, error)
	// CK_RV m_VerifyInit (
	//     unsigned char *state, size_t *statelen,
	//     CK_MECHANISM_PTR mech,
	//     const unsigned char *pubKey, size_t pubKeylen,
	//     target_t target) ;
	VerifyInit(context.Context, *VerifyInitRequest) (*VerifyInitResponse, error)
	// CK_RV m_SignUpdate (
	//     unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR data, CK_ULONG datalen,
	//     target_t target) ;
	SignUpdate(context.Context, *SignUpdateRequest) (*SignUpdateResponse, error)
	// CK_RV m_VerifyUpdate (
	//     unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR data, CK_ULONG datalen,
	//     target_t target) ;
	VerifyUpdate(context.Context, *VerifyUpdateRequest) (*VerifyUpdateResponse, error)
	// CK_RV m_SignFinal (
	//     const unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR signature, CK_ULONG_PTR signaturelen,
	//     target_t target) ;
	SignFinal(context.Context, *SignFinalRequest) (*SignFinalResponse, error)
	// CK_RV m_VerifyFinal (
	//     const unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR signature, CK_ULONG signaturelen,
	//     target_t target) ;
	VerifyFinal(context.Context, *VerifyFinalRequest) (*VerifyFinalResponse, error)
	// CK_RV m_Sign (
	//     const unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR data, CK_ULONG datalen,
	//     CK_BYTE_PTR signature, CK_ULONG_PTR signaturelen,
	//     target_t target) ;
	Sign(context.Context, *SignRequest) (*SignResponse, error)
	// CK_RV m_Verify (
	//     const unsigned char *state, size_t statelen,
	//     CK_BYTE_PTR data, CK_ULONG datalen,
	//     CK_BYTE_PTR signature, CK_ULONG signaturelen,
	//     target_t target) ;
	Verify(context.Context, *VerifyRequest) (*VerifyResponse, error)
	// CK_RV m_SignSingle (
	//     const unsigned char *privKey, size_t privKeylen,
	//     CK_MECHANISM_PTR mech,
	//     CK_BYTE_PTR data, CK_ULONG datalen,
	//     CK_BYTE_PTR signature, CK_ULONG_PTR signaturelen,
	//     target_t target) ;
	SignSingle(context.Context, *SignSingleRequest) (*SignSingleResponse, error)
	// CK_RV m_VerifySingle (
	//     const unsigned char *pubKey, size_t pubKeylen,
	//     CK_MECHANISM_PTR mech,
	//     CK_BYTE_PTR data, CK_ULONG datalen,
	//     CK_BYTE_PTR signature, CK_ULONG signaturelen,
	//     target_t target) ;
	VerifySingle(context.Context, *VerifySingleRequest) (*VerifySingleResponse, error)
	// CK_RV m_GenerateKey (
	//     CK_MECHANISM_PTR mech,
	//     CK_ATTRIBUTE_PTR templateBytes, CK_ULONG templateByteslen,
	//     const unsigned char *pin, size_t pinlen,
	//     unsigned char *keyBytes, size_t *keyByteslen,
	//     unsigned char *checkSum, size_t *checkSumlen,
	//     target_t target) ;
	GenerateKey(context.Context, *GenerateKeyRequest) (*GenerateKeyResponse, error)
	// CK_RV m_GenerateKeyPair (
	//     CK_MECHANISM_PTR mech,
	//     CK_ATTRIBUTE_PTR pubKeyTemplateBytes, CK_ULONG pubKeyTemplateByteslen,
	//     CK_ATTRIBUTE_PTR privKeyTemplateBytes, CK_ULONG privKeyTemplateByteslen,
	//     const unsigned char *pin, size_t pinlen,
	//     unsigned char *privKeyBytes, size_t *privKeyByteslen,
	//     unsigned char *pubKeyBytes, size_t *pubKeyByteslen,
	//     target_t target) ;
	GenerateKeyPair(context.Context, *GenerateKeyPairRequest) (*GenerateKeyPairResponse, error)
	// CK_RV m_WrapKey (
	//     const unsigned char *key, size_t keylen,
	//     const unsigned char *keK, size_t keKlen,
	//     const unsigned char *macKey, size_t macKeylen,
	//     const CK_MECHANISM_PTR mech,
	//     CK_BYTE_PTR wrapped, CK_ULONG_PTR wrappedlen,
	//     target_t target) ;
	WrapKey(context.Context, *WrapKeyRequest) (*WrapKeyResponse, error)
	// CK_RV m_UnwrapKey (
	//     const CK_BYTE_PTR wrapped, CK_ULONG wrappedlen,
	//     const unsigned char *keK, size_t keKlen,
	//     const unsigned char *macKey, size_t macKeylen,
	//     const unsigned char *pin, size_t pinlen,
	//     const CK_MECHANISM_PTR mech,
	//     const CK_ATTRIBUTE_PTR templateBytes, CK_ULONG templateByteslen,
	//     unsigned char *unwrappedBytes, size_t *unwrappedByteslen,
	//     CK_BYTE_PTR checkSum, CK_ULONG *checkSumlen,
	//     target_t target) ;
	UnwrapKey(context.Context, *UnwrapKeyRequest) (*UnwrapKeyResponse, error)
	// CK_RV m_DeriveKey (
	//     CK_MECHANISM_PTR mech,
	//     CK_ATTRIBUTE_PTR templateBytes, CK_ULONG templateByteslen,
	//     const unsigned char *baseKey, size_t baseKeylen,
	//     const unsigned char *data, size_t datalen,
	//     const unsigned char *pin, size_t pinlen,
	//     unsigned char *newKeyBytes, size_t *newKeyByteslen,
	//     unsigned char *checkSum, size_t *checkSumlen,
	//     target_t target) ;
	DeriveKey(context.Context, *DeriveKeyRequest) (*DeriveKeyResponse, error)
	// CK_RV m_GetMechanismList (
	//     CK_SLOT_ID slot,
	//     CK_MECHANISM_TYPE_PTR mechs, CK_ULONG_PTR mechslen,
	//     target_t target) ;
	GetMechanismList(context.Context, *GetMechanismListRequest) (*GetMechanismListResponse, error)
	// CK_RV m_GetMechanismInfo (
	//     CK_SLOT_ID slot,
	//     CK_MECHANISM_TYPE mech,
	//     CK_MECHANISM_INFO_PTR mechInfo,
	//     target_t target) ;
	GetMechanismInfo(context.Context, *GetMechanismInfoRequest) (*GetMechanismInfoResponse, error)
	// CK_RV m_GetAttributeValue (
	//     const unsigned char *object, size_t objectlen,
	//     CK_ATTRIBUTE_PTR attributesBytes, CK_ULONG attributesByteslen,
	//     target_t target) ;
	GetAttributeValue(context.Context, *GetAttributeValueRequest) (*GetAttributeValueResponse, error)
	// CK_RV m_SetAttributeValue (
	//     unsigned char *object, size_t objectlen,
	//     CK_ATTRIBUTE_PTR attributesBytes, CK_ULONG attributesByteslen,
	//     target_t target) ;
	SetAttributeValue(context.Context, *SetAttributeValueRequest) (*SetAttributeValueResponse, error)
	// CK_RV m_Login (
	//     CK_UTF8CHAR_PTR pin, CK_ULONG pinLen,
	//     const unsigned char *nonce, size_t noncelen,
	//     unsigned char *pinblob, size_t *pinbloblen,
	//     target_t target) ;
	Login(context.Context, *LoginRequest) (*LoginResponse, error)
	// CK_RV m_Logout (
	//     const unsigned char *pinblob, size_t pinbloblen,
	//     target_t target) ;
	Logout(context.Context, *LogoutRequest) (*LogoutResponse, error)
	RewrapKeyBlob(context.Context, *RewrapKeyBlobRequest) (*RewrapKeyBlobResponse, error)
}

// UnimplementedCryptoServer can be embedded to have forward compatible implementations.
type UnimplementedCryptoServer struct {
}

func (*UnimplementedCryptoServer) GenerateRandom(ctx context.Context, req *GenerateRandomRequest) (*GenerateRandomResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateRandom not implemented")
}
func (*UnimplementedCryptoServer) DigestInit(ctx context.Context, req *DigestInitRequest) (*DigestInitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DigestInit not implemented")
}
func (*UnimplementedCryptoServer) Digest(ctx context.Context, req *DigestRequest) (*DigestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Digest not implemented")
}
func (*UnimplementedCryptoServer) DigestUpdate(ctx context.Context, req *DigestUpdateRequest) (*DigestUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DigestUpdate not implemented")
}
func (*UnimplementedCryptoServer) DigestKey(ctx context.Context, req *DigestKeyRequest) (*DigestKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DigestKey not implemented")
}
func (*UnimplementedCryptoServer) DigestFinal(ctx context.Context, req *DigestFinalRequest) (*DigestFinalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DigestFinal not implemented")
}
func (*UnimplementedCryptoServer) DigestSingle(ctx context.Context, req *DigestSingleRequest) (*DigestSingleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DigestSingle not implemented")
}
func (*UnimplementedCryptoServer) EncryptInit(ctx context.Context, req *EncryptInitRequest) (*EncryptInitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EncryptInit not implemented")
}
func (*UnimplementedCryptoServer) DecryptInit(ctx context.Context, req *DecryptInitRequest) (*DecryptInitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DecryptInit not implemented")
}
func (*UnimplementedCryptoServer) EncryptUpdate(ctx context.Context, req *EncryptUpdateRequest) (*EncryptUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EncryptUpdate not implemented")
}
func (*UnimplementedCryptoServer) DecryptUpdate(ctx context.Context, req *DecryptUpdateRequest) (*DecryptUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DecryptUpdate not implemented")
}
func (*UnimplementedCryptoServer) Encrypt(ctx context.Context, req *EncryptRequest) (*EncryptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Encrypt not implemented")
}
func (*UnimplementedCryptoServer) Decrypt(ctx context.Context, req *DecryptRequest) (*DecryptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Decrypt not implemented")
}
func (*UnimplementedCryptoServer) EncryptFinal(ctx context.Context, req *EncryptFinalRequest) (*EncryptFinalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EncryptFinal not implemented")
}
func (*UnimplementedCryptoServer) DecryptFinal(ctx context.Context, req *DecryptFinalRequest) (*DecryptFinalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DecryptFinal not implemented")
}
func (*UnimplementedCryptoServer) EncryptSingle(ctx context.Context, req *EncryptSingleRequest) (*EncryptSingleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EncryptSingle not implemented")
}
func (*UnimplementedCryptoServer) DecryptSingle(ctx context.Context, req *DecryptSingleRequest) (*DecryptSingleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DecryptSingle not implemented")
}
func (*UnimplementedCryptoServer) SignInit(ctx context.Context, req *SignInitRequest) (*SignInitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignInit not implemented")
}
func (*UnimplementedCryptoServer) VerifyInit(ctx context.Context, req *VerifyInitRequest) (*VerifyInitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyInit not implemented")
}
func (*UnimplementedCryptoServer) SignUpdate(ctx context.Context, req *SignUpdateRequest) (*SignUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignUpdate not implemented")
}
func (*UnimplementedCryptoServer) VerifyUpdate(ctx context.Context, req *VerifyUpdateRequest) (*VerifyUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyUpdate not implemented")
}
func (*UnimplementedCryptoServer) SignFinal(ctx context.Context, req *SignFinalRequest) (*SignFinalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignFinal not implemented")
}
func (*UnimplementedCryptoServer) VerifyFinal(ctx context.Context, req *VerifyFinalRequest) (*VerifyFinalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyFinal not implemented")
}
func (*UnimplementedCryptoServer) Sign(ctx context.Context, req *SignRequest) (*SignResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Sign not implemented")
}
func (*UnimplementedCryptoServer) Verify(ctx context.Context, req *VerifyRequest) (*VerifyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Verify not implemented")
}
func (*UnimplementedCryptoServer) SignSingle(ctx context.Context, req *SignSingleRequest) (*SignSingleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignSingle not implemented")
}
func (*UnimplementedCryptoServer) VerifySingle(ctx context.Context, req *VerifySingleRequest) (*VerifySingleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifySingle not implemented")
}
func (*UnimplementedCryptoServer) GenerateKey(ctx context.Context, req *GenerateKeyRequest) (*GenerateKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateKey not implemented")
}
func (*UnimplementedCryptoServer) GenerateKeyPair(ctx context.Context, req *GenerateKeyPairRequest) (*GenerateKeyPairResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateKeyPair not implemented")
}
func (*UnimplementedCryptoServer) WrapKey(ctx context.Context, req *WrapKeyRequest) (*WrapKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WrapKey not implemented")
}
func (*UnimplementedCryptoServer) UnwrapKey(ctx context.Context, req *UnwrapKeyRequest) (*UnwrapKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnwrapKey not implemented")
}
func (*UnimplementedCryptoServer) DeriveKey(ctx context.Context, req *DeriveKeyRequest) (*DeriveKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeriveKey not implemented")
}
func (*UnimplementedCryptoServer) GetMechanismList(ctx context.Context, req *GetMechanismListRequest) (*GetMechanismListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMechanismList not implemented")
}
func (*UnimplementedCryptoServer) GetMechanismInfo(ctx context.Context, req *GetMechanismInfoRequest) (*GetMechanismInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMechanismInfo not implemented")
}
func (*UnimplementedCryptoServer) GetAttributeValue(ctx context.Context, req *GetAttributeValueRequest) (*GetAttributeValueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAttributeValue not implemented")
}
func (*UnimplementedCryptoServer) SetAttributeValue(ctx context.Context, req *SetAttributeValueRequest) (*SetAttributeValueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetAttributeValue not implemented")
}
func (*UnimplementedCryptoServer) Login(ctx context.Context, req *LoginRequest) (*LoginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (*UnimplementedCryptoServer) Logout(ctx context.Context, req *LogoutRequest) (*LogoutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Logout not implemented")
}
func (*UnimplementedCryptoServer) RewrapKeyBlob(ctx context.Context, req *RewrapKeyBlobRequest) (*RewrapKeyBlobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RewrapKeyBlob not implemented")
}

func RegisterCryptoServer(s *grpc.Server, srv CryptoServer) {
	s.RegisterService(&_Crypto_serviceDesc, srv)
}

func _Crypto_GenerateRandom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateRandomRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).GenerateRandom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/GenerateRandom",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).GenerateRandom(ctx, req.(*GenerateRandomRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_DigestInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DigestInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).DigestInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/DigestInit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).DigestInit(ctx, req.(*DigestInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_Digest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DigestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).Digest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/Digest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).Digest(ctx, req.(*DigestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_DigestUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DigestUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).DigestUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/DigestUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).DigestUpdate(ctx, req.(*DigestUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_DigestKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DigestKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).DigestKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/DigestKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).DigestKey(ctx, req.(*DigestKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_DigestFinal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DigestFinalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).DigestFinal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/DigestFinal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).DigestFinal(ctx, req.(*DigestFinalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_DigestSingle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DigestSingleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).DigestSingle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/DigestSingle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).DigestSingle(ctx, req.(*DigestSingleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_EncryptInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EncryptInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).EncryptInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/EncryptInit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).EncryptInit(ctx, req.(*EncryptInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_DecryptInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecryptInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).DecryptInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/DecryptInit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).DecryptInit(ctx, req.(*DecryptInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_EncryptUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EncryptUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).EncryptUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/EncryptUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).EncryptUpdate(ctx, req.(*EncryptUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_DecryptUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecryptUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).DecryptUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/DecryptUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).DecryptUpdate(ctx, req.(*DecryptUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_Encrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EncryptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).Encrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/Encrypt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).Encrypt(ctx, req.(*EncryptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_Decrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecryptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).Decrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/Decrypt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).Decrypt(ctx, req.(*DecryptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_EncryptFinal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EncryptFinalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).EncryptFinal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/EncryptFinal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).EncryptFinal(ctx, req.(*EncryptFinalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_DecryptFinal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecryptFinalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).DecryptFinal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/DecryptFinal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).DecryptFinal(ctx, req.(*DecryptFinalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_EncryptSingle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EncryptSingleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).EncryptSingle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/EncryptSingle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).EncryptSingle(ctx, req.(*EncryptSingleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_DecryptSingle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecryptSingleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).DecryptSingle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/DecryptSingle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).DecryptSingle(ctx, req.(*DecryptSingleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_SignInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).SignInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/SignInit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).SignInit(ctx, req.(*SignInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_VerifyInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).VerifyInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/VerifyInit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).VerifyInit(ctx, req.(*VerifyInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_SignUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).SignUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/SignUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).SignUpdate(ctx, req.(*SignUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_VerifyUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).VerifyUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/VerifyUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).VerifyUpdate(ctx, req.(*VerifyUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_SignFinal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignFinalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).SignFinal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/SignFinal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).SignFinal(ctx, req.(*SignFinalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_VerifyFinal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyFinalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).VerifyFinal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/VerifyFinal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).VerifyFinal(ctx, req.(*VerifyFinalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_Sign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).Sign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/Sign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).Sign(ctx, req.(*SignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_Verify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).Verify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/Verify",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).Verify(ctx, req.(*VerifyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_SignSingle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignSingleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).SignSingle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/SignSingle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).SignSingle(ctx, req.(*SignSingleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_VerifySingle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifySingleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).VerifySingle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/VerifySingle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).VerifySingle(ctx, req.(*VerifySingleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_GenerateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).GenerateKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/GenerateKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).GenerateKey(ctx, req.(*GenerateKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_GenerateKeyPair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateKeyPairRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).GenerateKeyPair(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/GenerateKeyPair",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).GenerateKeyPair(ctx, req.(*GenerateKeyPairRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_WrapKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WrapKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).WrapKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/WrapKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).WrapKey(ctx, req.(*WrapKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_UnwrapKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnwrapKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).UnwrapKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/UnwrapKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).UnwrapKey(ctx, req.(*UnwrapKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_DeriveKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeriveKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).DeriveKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/DeriveKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).DeriveKey(ctx, req.(*DeriveKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_GetMechanismList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMechanismListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).GetMechanismList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/GetMechanismList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).GetMechanismList(ctx, req.(*GetMechanismListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_GetMechanismInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMechanismInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).GetMechanismInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/GetMechanismInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).GetMechanismInfo(ctx, req.(*GetMechanismInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_GetAttributeValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAttributeValueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).GetAttributeValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/GetAttributeValue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).GetAttributeValue(ctx, req.(*GetAttributeValueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_SetAttributeValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetAttributeValueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).SetAttributeValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/SetAttributeValue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).SetAttributeValue(ctx, req.(*SetAttributeValueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/Login",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).Login(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_Logout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).Logout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/Logout",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).Logout(ctx, req.(*LogoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Crypto_RewrapKeyBlob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RewrapKeyBlobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoServer).RewrapKeyBlob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grep11.Crypto/RewrapKeyBlob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoServer).RewrapKeyBlob(ctx, req.(*RewrapKeyBlobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Crypto_serviceDesc = grpc.ServiceDesc{
	ServiceName: "grep11.Crypto",
	HandlerType: (*CryptoServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GenerateRandom",
			Handler:    _Crypto_GenerateRandom_Handler,
		},
		{
			MethodName: "DigestInit",
			Handler:    _Crypto_DigestInit_Handler,
		},
		{
			MethodName: "Digest",
			Handler:    _Crypto_Digest_Handler,
		},
		{
			MethodName: "DigestUpdate",
			Handler:    _Crypto_DigestUpdate_Handler,
		},
		{
			MethodName: "DigestKey",
			Handler:    _Crypto_DigestKey_Handler,
		},
		{
			MethodName: "DigestFinal",
			Handler:    _Crypto_DigestFinal_Handler,
		},
		{
			MethodName: "DigestSingle",
			Handler:    _Crypto_DigestSingle_Handler,
		},
		{
			MethodName: "EncryptInit",
			Handler:    _Crypto_EncryptInit_Handler,
		},
		{
			MethodName: "DecryptInit",
			Handler:    _Crypto_DecryptInit_Handler,
		},
		{
			MethodName: "EncryptUpdate",
			Handler:    _Crypto_EncryptUpdate_Handler,
		},
		{
			MethodName: "DecryptUpdate",
			Handler:    _Crypto_DecryptUpdate_Handler,
		},
		{
			MethodName: "Encrypt",
			Handler:    _Crypto_Encrypt_Handler,
		},
		{
			MethodName: "Decrypt",
			Handler:    _Crypto_Decrypt_Handler,
		},
		{
			MethodName: "EncryptFinal",
			Handler:    _Crypto_EncryptFinal_Handler,
		},
		{
			MethodName: "DecryptFinal",
			Handler:    _Crypto_DecryptFinal_Handler,
		},
		{
			MethodName: "EncryptSingle",
			Handler:    _Crypto_EncryptSingle_Handler,
		},
		{
			MethodName: "DecryptSingle",
			Handler:    _Crypto_DecryptSingle_Handler,
		},
		{
			MethodName: "SignInit",
			Handler:    _Crypto_SignInit_Handler,
		},
		{
			MethodName: "VerifyInit",
			Handler:    _Crypto_VerifyInit_Handler,
		},
		{
			MethodName: "SignUpdate",
			Handler:    _Crypto_SignUpdate_Handler,
		},
		{
			MethodName: "VerifyUpdate",
			Handler:    _Crypto_VerifyUpdate_Handler,
		},
		{
			MethodName: "SignFinal",
			Handler:    _Crypto_SignFinal_Handler,
		},
		{
			MethodName: "VerifyFinal",
			Handler:    _Crypto_VerifyFinal_Handler,
		},
		{
			MethodName: "Sign",
			Handler:    _Crypto_Sign_Handler,
		},
		{
			MethodName: "Verify",
			Handler:    _Crypto_Verify_Handler,
		},
		{
			MethodName: "SignSingle",
			Handler:    _Crypto_SignSingle_Handler,
		},
		{
			MethodName: "VerifySingle",
			Handler:    _Crypto_VerifySingle_Handler,
		},
		{
			MethodName: "GenerateKey",
			Handler:    _Crypto_GenerateKey_Handler,
		},
		{
			MethodName: "GenerateKeyPair",
			Handler:    _Crypto_GenerateKeyPair_Handler,
		},
		{
			MethodName: "WrapKey",
			Handler:    _Crypto_WrapKey_Handler,
		},
		{
			MethodName: "UnwrapKey",
			Handler:    _Crypto_UnwrapKey_Handler,
		},
		{
			MethodName: "DeriveKey",
			Handler:    _Crypto_DeriveKey_Handler,
		},
		{
			MethodName: "GetMechanismList",
			Handler:    _Crypto_GetMechanismList_Handler,
		},
		{
			MethodName: "GetMechanismInfo",
			Handler:    _Crypto_GetMechanismInfo_Handler,
		},
		{
			MethodName: "GetAttributeValue",
			Handler:    _Crypto_GetAttributeValue_Handler,
		},
		{
			MethodName: "SetAttributeValue",
			Handler:    _Crypto_SetAttributeValue_Handler,
		},
		{
			MethodName: "Login",
			Handler:    _Crypto_Login_Handler,
		},
		{
			MethodName: "Logout",
			Handler:    _Crypto_Logout_Handler,
		},
		{
			MethodName: "RewrapKeyBlob",
			Handler:    _Crypto_RewrapKeyBlob_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "server.proto",
}

func (m *GenerateRandomRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenerateRandomRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenerateRandomRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Len != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.Len))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GenerateRandomResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenerateRandomResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenerateRandomResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Rnd) > 0 {
		i -= len(m.Rnd)
		copy(dAtA[i:], m.Rnd)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Rnd)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DigestInitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DigestInitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DigestInitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mech != nil {
		{
			size, err := m.Mech.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *DigestInitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DigestInitResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DigestInitResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DigestRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DigestRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DigestRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DigestResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DigestResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DigestResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Digest) > 0 {
		i -= len(m.Digest)
		copy(dAtA[i:], m.Digest)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Digest)))
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *DigestUpdateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DigestUpdateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DigestUpdateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DigestUpdateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DigestUpdateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DigestUpdateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DigestKeyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DigestKeyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DigestKeyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DigestKeyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DigestKeyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DigestKeyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DigestFinalRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DigestFinalRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DigestFinalRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DigestFinalResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DigestFinalResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DigestFinalResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Digest) > 0 {
		i -= len(m.Digest)
		copy(dAtA[i:], m.Digest)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Digest)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *DigestSingleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DigestSingleRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DigestSingleRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if m.Mech != nil {
		{
			size, err := m.Mech.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DigestSingleResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DigestSingleResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DigestSingleResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Digest) > 0 {
		i -= len(m.Digest)
		copy(dAtA[i:], m.Digest)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Digest)))
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *EncryptInitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptInitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptInitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Mech != nil {
		{
			size, err := m.Mech.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *EncryptInitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptInitResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptInitResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DecryptInitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecryptInitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DecryptInitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Mech != nil {
		{
			size, err := m.Mech.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *DecryptInitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecryptInitResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DecryptInitResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EncryptUpdateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptUpdateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptUpdateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Plain) > 0 {
		i -= len(m.Plain)
		copy(dAtA[i:], m.Plain)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Plain)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EncryptUpdateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptUpdateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptUpdateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Ciphered) > 0 {
		i -= len(m.Ciphered)
		copy(dAtA[i:], m.Ciphered)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Ciphered)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DecryptUpdateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecryptUpdateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DecryptUpdateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Ciphered) > 0 {
		i -= len(m.Ciphered)
		copy(dAtA[i:], m.Ciphered)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Ciphered)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DecryptUpdateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecryptUpdateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DecryptUpdateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Plain) > 0 {
		i -= len(m.Plain)
		copy(dAtA[i:], m.Plain)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Plain)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EncryptRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Plain) > 0 {
		i -= len(m.Plain)
		copy(dAtA[i:], m.Plain)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Plain)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EncryptResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Ciphered) > 0 {
		i -= len(m.Ciphered)
		copy(dAtA[i:], m.Ciphered)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Ciphered)))
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *DecryptRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecryptRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DecryptRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Ciphered) > 0 {
		i -= len(m.Ciphered)
		copy(dAtA[i:], m.Ciphered)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Ciphered)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DecryptResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecryptResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DecryptResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Plain) > 0 {
		i -= len(m.Plain)
		copy(dAtA[i:], m.Plain)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Plain)))
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *EncryptFinalRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptFinalRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptFinalRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EncryptFinalResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptFinalResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptFinalResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Ciphered) > 0 {
		i -= len(m.Ciphered)
		copy(dAtA[i:], m.Ciphered)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Ciphered)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *DecryptFinalRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecryptFinalRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DecryptFinalRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DecryptFinalResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecryptFinalResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DecryptFinalResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Plain) > 0 {
		i -= len(m.Plain)
		copy(dAtA[i:], m.Plain)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Plain)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *EncryptSingleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptSingleRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptSingleRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Plain) > 0 {
		i -= len(m.Plain)
		copy(dAtA[i:], m.Plain)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Plain)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Mech != nil {
		{
			size, err := m.Mech.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EncryptSingleResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptSingleResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptSingleResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Ciphered) > 0 {
		i -= len(m.Ciphered)
		copy(dAtA[i:], m.Ciphered)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Ciphered)))
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}

func (m *DecryptSingleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecryptSingleRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DecryptSingleRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Ciphered) > 0 {
		i -= len(m.Ciphered)
		copy(dAtA[i:], m.Ciphered)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Ciphered)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Mech != nil {
		{
			size, err := m.Mech.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DecryptSingleResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecryptSingleResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DecryptSingleResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Plain) > 0 {
		i -= len(m.Plain)
		copy(dAtA[i:], m.Plain)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Plain)))
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}

func (m *SignInitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignInitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignInitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PrivKey) > 0 {
		i -= len(m.PrivKey)
		copy(dAtA[i:], m.PrivKey)
		i = encodeVarintServer(dAtA, i, uint64(len(m.PrivKey)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Mech != nil {
		{
			size, err := m.Mech.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *SignInitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignInitResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignInitResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VerifyInitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyInitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifyInitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PubKey) > 0 {
		i -= len(m.PubKey)
		copy(dAtA[i:], m.PubKey)
		i = encodeVarintServer(dAtA, i, uint64(len(m.PubKey)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Mech != nil {
		{
			size, err := m.Mech.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *VerifyInitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyInitResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifyInitResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SignUpdateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignUpdateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignUpdateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SignUpdateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignUpdateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignUpdateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VerifyUpdateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyUpdateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifyUpdateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VerifyUpdateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyUpdateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifyUpdateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SignFinalRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignFinalRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignFinalRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SignFinalResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignFinalResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignFinalResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *VerifyFinalRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyFinalRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifyFinalRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VerifyFinalResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyFinalResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifyFinalResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *SignRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SignResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *VerifyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintServer(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VerifyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *SignSingleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignSingleRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignSingleRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Mech != nil {
		{
			size, err := m.Mech.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.PrivKey) > 0 {
		i -= len(m.PrivKey)
		copy(dAtA[i:], m.PrivKey)
		i = encodeVarintServer(dAtA, i, uint64(len(m.PrivKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SignSingleResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignSingleResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignSingleResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}

func (m *VerifySingleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifySingleRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifySingleRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Mech != nil {
		{
			size, err := m.Mech.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.PubKey) > 0 {
		i -= len(m.PubKey)
		copy(dAtA[i:], m.PubKey)
		i = encodeVarintServer(dAtA, i, uint64(len(m.PubKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VerifySingleResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifySingleResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifySingleResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *GenerateKeyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenerateKeyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenerateKeyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Template) > 0 {
		for k := range m.Template {
			v := m.Template[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintServer(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintServer(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintServer(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Mech != nil {
		{
			size, err := m.Mech.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GenerateKeyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenerateKeyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenerateKeyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Key != nil {
		{
			size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.CheckSum) > 0 {
		i -= len(m.CheckSum)
		copy(dAtA[i:], m.CheckSum)
		i = encodeVarintServer(dAtA, i, uint64(len(m.CheckSum)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.KeyBytes) > 0 {
		i -= len(m.KeyBytes)
		copy(dAtA[i:], m.KeyBytes)
		i = encodeVarintServer(dAtA, i, uint64(len(m.KeyBytes)))
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}

func (m *GenerateKeyPairRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenerateKeyPairRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenerateKeyPairRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PubKeyTemplate) > 0 {
		for k := range m.PubKeyTemplate {
			v := m.PubKeyTemplate[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintServer(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintServer(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintServer(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.PrivKeyTemplate) > 0 {
		for k := range m.PrivKeyTemplate {
			v := m.PrivKeyTemplate[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintServer(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintServer(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintServer(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Mech != nil {
		{
			size, err := m.Mech.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GenerateKeyPairResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenerateKeyPairResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenerateKeyPairResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PubKey != nil {
		{
			size, err := m.PubKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.PrivKey != nil {
		{
			size, err := m.PrivKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.PubKeyBytes) > 0 {
		i -= len(m.PubKeyBytes)
		copy(dAtA[i:], m.PubKeyBytes)
		i = encodeVarintServer(dAtA, i, uint64(len(m.PubKeyBytes)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.PrivKeyBytes) > 0 {
		i -= len(m.PrivKeyBytes)
		copy(dAtA[i:], m.PrivKeyBytes)
		i = encodeVarintServer(dAtA, i, uint64(len(m.PrivKeyBytes)))
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}

func (m *WrapKeyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WrapKeyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WrapKeyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mech != nil {
		{
			size, err := m.Mech.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.MacKey) > 0 {
		i -= len(m.MacKey)
		copy(dAtA[i:], m.MacKey)
		i = encodeVarintServer(dAtA, i, uint64(len(m.MacKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.KeK) > 0 {
		i -= len(m.KeK)
		copy(dAtA[i:], m.KeK)
		i = encodeVarintServer(dAtA, i, uint64(len(m.KeK)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WrapKeyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WrapKeyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WrapKeyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Wrapped) > 0 {
		i -= len(m.Wrapped)
		copy(dAtA[i:], m.Wrapped)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Wrapped)))
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}

func (m *UnwrapKeyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnwrapKeyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnwrapKeyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Template) > 0 {
		for k := range m.Template {
			v := m.Template[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintServer(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintServer(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintServer(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.Mech != nil {
		{
			size, err := m.Mech.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.MacKey) > 0 {
		i -= len(m.MacKey)
		copy(dAtA[i:], m.MacKey)
		i = encodeVarintServer(dAtA, i, uint64(len(m.MacKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.KeK) > 0 {
		i -= len(m.KeK)
		copy(dAtA[i:], m.KeK)
		i = encodeVarintServer(dAtA, i, uint64(len(m.KeK)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Wrapped) > 0 {
		i -= len(m.Wrapped)
		copy(dAtA[i:], m.Wrapped)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Wrapped)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UnwrapKeyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnwrapKeyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnwrapKeyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Unwrapped != nil {
		{
			size, err := m.Unwrapped.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.CheckSum) > 0 {
		i -= len(m.CheckSum)
		copy(dAtA[i:], m.CheckSum)
		i = encodeVarintServer(dAtA, i, uint64(len(m.CheckSum)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.UnwrappedBytes) > 0 {
		i -= len(m.UnwrappedBytes)
		copy(dAtA[i:], m.UnwrappedBytes)
		i = encodeVarintServer(dAtA, i, uint64(len(m.UnwrappedBytes)))
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}

func (m *DeriveKeyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveKeyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveKeyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Template) > 0 {
		for k := range m.Template {
			v := m.Template[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintServer(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintServer(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintServer(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.BaseKey) > 0 {
		i -= len(m.BaseKey)
		copy(dAtA[i:], m.BaseKey)
		i = encodeVarintServer(dAtA, i, uint64(len(m.BaseKey)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Mech != nil {
		{
			size, err := m.Mech.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeriveKeyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeriveKeyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeriveKeyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NewKey != nil {
		{
			size, err := m.NewKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.CheckSum) > 0 {
		i -= len(m.CheckSum)
		copy(dAtA[i:], m.CheckSum)
		i = encodeVarintServer(dAtA, i, uint64(len(m.CheckSum)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.NewKeyBytes) > 0 {
		i -= len(m.NewKeyBytes)
		copy(dAtA[i:], m.NewKeyBytes)
		i = encodeVarintServer(dAtA, i, uint64(len(m.NewKeyBytes)))
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}

func (m *GetMechanismListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMechanismListRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetMechanismListRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *GetMechanismListResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMechanismListResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetMechanismListResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Mechs) > 0 {
		dAtA27 := make([]byte, len(m.Mechs)*10)
		var j26 int
		for _, num := range m.Mechs {
			for num >= 1<<7 {
				dAtA27[j26] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j26++
			}
			dAtA27[j26] = uint8(num)
			j26++
		}
		i -= j26
		copy(dAtA[i:], dAtA27[:j26])
		i = encodeVarintServer(dAtA, i, uint64(j26))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *GetMechanismInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMechanismInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetMechanismInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mech != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.Mech))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *GetMechanismInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMechanismInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetMechanismInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MechInfo != nil {
		{
			size, err := m.MechInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *GetAttributeValueRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAttributeValueRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAttributeValueRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Attributes) > 0 {
		for k := range m.Attributes {
			v := m.Attributes[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintServer(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintServer(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintServer(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.AttributesBytes) > 0 {
		for k := range m.AttributesBytes {
			v := m.AttributesBytes[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintServer(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintServer(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintServer(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Object) > 0 {
		i -= len(m.Object)
		copy(dAtA[i:], m.Object)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Object)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetAttributeValueResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAttributeValueResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAttributeValueResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Attributes) > 0 {
		for k := range m.Attributes {
			v := m.Attributes[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintServer(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintServer(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintServer(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.AttributesBytes) > 0 {
		for k := range m.AttributesBytes {
			v := m.AttributesBytes[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintServer(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintServer(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintServer(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *SetAttributeValueRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetAttributeValueRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetAttributeValueRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Attributes) > 0 {
		for k := range m.Attributes {
			v := m.Attributes[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintServer(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintServer(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintServer(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Object) > 0 {
		i -= len(m.Object)
		copy(dAtA[i:], m.Object)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Object)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetAttributeValueResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetAttributeValueResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetAttributeValueResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Object) > 0 {
		i -= len(m.Object)
		copy(dAtA[i:], m.Object)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Object)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LoginRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoginRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Pin) > 0 {
		i -= len(m.Pin)
		copy(dAtA[i:], m.Pin)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Pin)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Storeid) > 0 {
		i -= len(m.Storeid)
		copy(dAtA[i:], m.Storeid)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Storeid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LoginResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoginResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Pinblob) > 0 {
		i -= len(m.Pinblob)
		copy(dAtA[i:], m.Pinblob)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Pinblob)))
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}

func (m *LogoutRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogoutRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogoutRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *LogoutResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogoutResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogoutResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *Mechanism) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Mechanism) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Mechanism) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Parameter != nil {
		{
			size := m.Parameter.Size()
			i -= size
			if _, err := m.Parameter.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Mechanism != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.Mechanism))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Mechanism_ParameterB) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Mechanism_ParameterB) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ParameterB != nil {
		i -= len(m.ParameterB)
		copy(dAtA[i:], m.ParameterB)
		i = encodeVarintServer(dAtA, i, uint64(len(m.ParameterB)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Mechanism_RSAOAEPParameter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Mechanism_RSAOAEPParameter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RSAOAEPParameter != nil {
		{
			size, err := m.RSAOAEPParameter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Mechanism_RSAPSSParameter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Mechanism_RSAPSSParameter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RSAPSSParameter != nil {
		{
			size, err := m.RSAPSSParameter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Mechanism_ECDH1DeriveParameter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Mechanism_ECDH1DeriveParameter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ECDH1DeriveParameter != nil {
		{
			size, err := m.ECDH1DeriveParameter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *MechanismInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MechanismInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MechanismInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Flags != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.Flags))
		i--
		dAtA[i] = 0x18
	}
	if m.MaxKeySize != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.MaxKeySize))
		i--
		dAtA[i] = 0x10
	}
	if m.MinKeySize != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.MinKeySize))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Grep11Error) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Grep11Error) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Grep11Error) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Retry {
		i--
		if m.Retry {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Detail) > 0 {
		i -= len(m.Detail)
		copy(dAtA[i:], m.Detail)
		i = encodeVarintServer(dAtA, i, uint64(len(m.Detail)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RSAOAEPParm) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RSAOAEPParm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RSAOAEPParm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.EncodingParm) > 0 {
		i -= len(m.EncodingParm)
		copy(dAtA[i:], m.EncodingParm)
		i = encodeVarintServer(dAtA, i, uint64(len(m.EncodingParm)))
		i--
		dAtA[i] = 0x22
	}
	if m.EncodingParmType != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.EncodingParmType))
		i--
		dAtA[i] = 0x18
	}
	if m.Mgf != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.Mgf))
		i--
		dAtA[i] = 0x10
	}
	if m.HashMech != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.HashMech))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RSAPSSParm) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RSAPSSParm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RSAPSSParm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SaltByteCount != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.SaltByteCount))
		i--
		dAtA[i] = 0x18
	}
	if m.Mgf != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.Mgf))
		i--
		dAtA[i] = 0x10
	}
	if m.HashMech != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.HashMech))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ECDH1DeriveParm) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ECDH1DeriveParm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ECDH1DeriveParm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PublicData) > 0 {
		i -= len(m.PublicData)
		copy(dAtA[i:], m.PublicData)
		i = encodeVarintServer(dAtA, i, uint64(len(m.PublicData)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SharedData) > 0 {
		i -= len(m.SharedData)
		copy(dAtA[i:], m.SharedData)
		i = encodeVarintServer(dAtA, i, uint64(len(m.SharedData)))
		i--
		dAtA[i] = 0x12
	}
	if m.Kdf != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.Kdf))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HMACGeneralParm) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HMACGeneralParm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HMACGeneralParm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ReturnByteCount != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.ReturnByteCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RewrapKeyBlobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewrapKeyBlobRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewrapKeyBlobRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.WrappedKey) > 0 {
		i -= len(m.WrappedKey)
		copy(dAtA[i:], m.WrappedKey)
		i = encodeVarintServer(dAtA, i, uint64(len(m.WrappedKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RewrapKeyBlobResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewrapKeyBlobResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewrapKeyBlobResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.KeyBlob != nil {
		{
			size, err := m.KeyBlob.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.RewrappedKey) > 0 {
		i -= len(m.RewrappedKey)
		copy(dAtA[i:], m.RewrappedKey)
		i = encodeVarintServer(dAtA, i, uint64(len(m.RewrappedKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AttributeValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttributeValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttributeValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OneAttr != nil {
		{
			size := m.OneAttr.Size()
			i -= size
			if _, err := m.OneAttr.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AttributeValue_AttributeB) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttributeValue_AttributeB) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AttributeB != nil {
		i -= len(m.AttributeB)
		copy(dAtA[i:], m.AttributeB)
		i = encodeVarintServer(dAtA, i, uint64(len(m.AttributeB)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *AttributeValue_AttributeTF) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttributeValue_AttributeTF) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.AttributeTF {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *AttributeValue_AttributeI) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttributeValue_AttributeI) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintServer(dAtA, i, uint64(m.AttributeI))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *KeyBlob) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyBlob) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyBlob) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.KeyBlobs) > 0 {
		for iNdEx := len(m.KeyBlobs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.KeyBlobs[iNdEx])
			copy(dAtA[i:], m.KeyBlobs[iNdEx])
			i = encodeVarintServer(dAtA, i, uint64(len(m.KeyBlobs[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Attributes) > 0 {
		for k := range m.Attributes {
			v := m.Attributes[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintServer(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintServer(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintServer(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintServer(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Version != 0 {
		i = encodeVarintServer(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x10
	}
	if len(m.KeyBlobID) > 0 {
		i -= len(m.KeyBlobID)
		copy(dAtA[i:], m.KeyBlobID)
		i = encodeVarintServer(dAtA, i, uint64(len(m.KeyBlobID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintServer(dAtA []byte, offset int, v uint64) int {
	offset -= sovServer(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GenerateRandomRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Len != 0 {
		n += 1 + sovServer(uint64(m.Len))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GenerateRandomResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Rnd)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DigestInitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mech != nil {
		l = m.Mech.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DigestInitResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DigestRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DigestResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Digest)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DigestUpdateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DigestUpdateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DigestKeyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DigestKeyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DigestFinalRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DigestFinalResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Digest)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DigestSingleRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mech != nil {
		l = m.Mech.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DigestSingleResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Digest)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EncryptInitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mech != nil {
		l = m.Mech.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EncryptInitResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DecryptInitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mech != nil {
		l = m.Mech.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DecryptInitResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EncryptUpdateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Plain)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EncryptUpdateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Ciphered)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DecryptUpdateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Ciphered)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DecryptUpdateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Plain)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EncryptRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Plain)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EncryptResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Ciphered)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DecryptRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Ciphered)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DecryptResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Plain)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EncryptFinalRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EncryptFinalResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Ciphered)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DecryptFinalRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DecryptFinalResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Plain)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EncryptSingleRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.Mech != nil {
		l = m.Mech.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Plain)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EncryptSingleResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Ciphered)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DecryptSingleRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.Mech != nil {
		l = m.Mech.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Ciphered)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DecryptSingleResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Plain)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SignInitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mech != nil {
		l = m.Mech.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.PrivKey)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SignInitResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VerifyInitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mech != nil {
		l = m.Mech.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VerifyInitResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SignUpdateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SignUpdateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VerifyUpdateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VerifyUpdateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SignFinalRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SignFinalResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VerifyFinalRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VerifyFinalResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SignRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SignResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VerifyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VerifyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SignSingleRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PrivKey)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.Mech != nil {
		l = m.Mech.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SignSingleResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VerifySingleRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.Mech != nil {
		l = m.Mech.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VerifySingleResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GenerateKeyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mech != nil {
		l = m.Mech.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	if len(m.Template) > 0 {
		for k, v := range m.Template {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovServer(uint64(l))
			}
			mapEntrySize := 1 + sovServer(uint64(k)) + l
			n += mapEntrySize + 1 + sovServer(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GenerateKeyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KeyBytes)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.CheckSum)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GenerateKeyPairRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mech != nil {
		l = m.Mech.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	if len(m.PrivKeyTemplate) > 0 {
		for k, v := range m.PrivKeyTemplate {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovServer(uint64(l))
			}
			mapEntrySize := 1 + sovServer(uint64(k)) + l
			n += mapEntrySize + 1 + sovServer(uint64(mapEntrySize))
		}
	}
	if len(m.PubKeyTemplate) > 0 {
		for k, v := range m.PubKeyTemplate {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovServer(uint64(l))
			}
			mapEntrySize := 1 + sovServer(uint64(k)) + l
			n += mapEntrySize + 1 + sovServer(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GenerateKeyPairResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PrivKeyBytes)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.PubKeyBytes)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.PrivKey != nil {
		l = m.PrivKey.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	if m.PubKey != nil {
		l = m.PubKey.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WrapKeyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.KeK)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.MacKey)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.Mech != nil {
		l = m.Mech.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WrapKeyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Wrapped)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnwrapKeyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Wrapped)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.KeK)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.MacKey)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.Mech != nil {
		l = m.Mech.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	if len(m.Template) > 0 {
		for k, v := range m.Template {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovServer(uint64(l))
			}
			mapEntrySize := 1 + sovServer(uint64(k)) + l
			n += mapEntrySize + 1 + sovServer(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnwrapKeyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UnwrappedBytes)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.CheckSum)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.Unwrapped != nil {
		l = m.Unwrapped.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveKeyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mech != nil {
		l = m.Mech.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.BaseKey)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if len(m.Template) > 0 {
		for k, v := range m.Template {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovServer(uint64(l))
			}
			mapEntrySize := 1 + sovServer(uint64(k)) + l
			n += mapEntrySize + 1 + sovServer(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeriveKeyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NewKeyBytes)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.CheckSum)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.NewKey != nil {
		l = m.NewKey.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetMechanismListRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetMechanismListResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Mechs) > 0 {
		l = 0
		for _, e := range m.Mechs {
			l += sovServer(uint64(e))
		}
		n += 1 + sovServer(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetMechanismInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mech != 0 {
		n += 1 + sovServer(uint64(m.Mech))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetMechanismInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MechInfo != nil {
		l = m.MechInfo.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetAttributeValueRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Object)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if len(m.AttributesBytes) > 0 {
		for k, v := range m.AttributesBytes {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovServer(uint64(len(v)))
			}
			mapEntrySize := 1 + sovServer(uint64(k)) + l
			n += mapEntrySize + 1 + sovServer(uint64(mapEntrySize))
		}
	}
	if len(m.Attributes) > 0 {
		for k, v := range m.Attributes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovServer(uint64(l))
			}
			mapEntrySize := 1 + sovServer(uint64(k)) + l
			n += mapEntrySize + 1 + sovServer(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetAttributeValueResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AttributesBytes) > 0 {
		for k, v := range m.AttributesBytes {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovServer(uint64(len(v)))
			}
			mapEntrySize := 1 + sovServer(uint64(k)) + l
			n += mapEntrySize + 1 + sovServer(uint64(mapEntrySize))
		}
	}
	if len(m.Attributes) > 0 {
		for k, v := range m.Attributes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovServer(uint64(l))
			}
			mapEntrySize := 1 + sovServer(uint64(k)) + l
			n += mapEntrySize + 1 + sovServer(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetAttributeValueRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Object)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if len(m.Attributes) > 0 {
		for k, v := range m.Attributes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovServer(uint64(l))
			}
			mapEntrySize := 1 + sovServer(uint64(k)) + l
			n += mapEntrySize + 1 + sovServer(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetAttributeValueResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Object)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoginRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Storeid)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.Pin)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoginResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Pinblob)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LogoutRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LogoutResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Mechanism) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mechanism != 0 {
		n += 1 + sovServer(uint64(m.Mechanism))
	}
	if m.Parameter != nil {
		n += m.Parameter.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Mechanism_ParameterB) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ParameterB != nil {
		l = len(m.ParameterB)
		n += 1 + l + sovServer(uint64(l))
	}
	return n
}
func (m *Mechanism_RSAOAEPParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RSAOAEPParameter != nil {
		l = m.RSAOAEPParameter.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	return n
}
func (m *Mechanism_RSAPSSParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RSAPSSParameter != nil {
		l = m.RSAPSSParameter.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	return n
}
func (m *Mechanism_ECDH1DeriveParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ECDH1DeriveParameter != nil {
		l = m.ECDH1DeriveParameter.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	return n
}
func (m *MechanismInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MinKeySize != 0 {
		n += 1 + sovServer(uint64(m.MinKeySize))
	}
	if m.MaxKeySize != 0 {
		n += 1 + sovServer(uint64(m.MaxKeySize))
	}
	if m.Flags != 0 {
		n += 1 + sovServer(uint64(m.Flags))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Grep11Error) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovServer(uint64(m.Code))
	}
	l = len(m.Detail)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.Retry {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RSAOAEPParm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HashMech != 0 {
		n += 1 + sovServer(uint64(m.HashMech))
	}
	if m.Mgf != 0 {
		n += 1 + sovServer(uint64(m.Mgf))
	}
	if m.EncodingParmType != 0 {
		n += 1 + sovServer(uint64(m.EncodingParmType))
	}
	l = len(m.EncodingParm)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RSAPSSParm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HashMech != 0 {
		n += 1 + sovServer(uint64(m.HashMech))
	}
	if m.Mgf != 0 {
		n += 1 + sovServer(uint64(m.Mgf))
	}
	if m.SaltByteCount != 0 {
		n += 1 + sovServer(uint64(m.SaltByteCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ECDH1DeriveParm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kdf != 0 {
		n += 1 + sovServer(uint64(m.Kdf))
	}
	l = len(m.SharedData)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	l = len(m.PublicData)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HMACGeneralParm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReturnByteCount != 0 {
		n += 1 + sovServer(uint64(m.ReturnByteCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RewrapKeyBlobRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.WrappedKey)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RewrapKeyBlobResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RewrappedKey)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.KeyBlob != nil {
		l = m.KeyBlob.Size()
		n += 1 + l + sovServer(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AttributeValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OneAttr != nil {
		n += m.OneAttr.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AttributeValue_AttributeB) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AttributeB != nil {
		l = len(m.AttributeB)
		n += 1 + l + sovServer(uint64(l))
	}
	return n
}
func (m *AttributeValue_AttributeTF) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *AttributeValue_AttributeI) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovServer(uint64(m.AttributeI))
	return n
}
func (m *KeyBlob) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KeyBlobID)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovServer(uint64(m.Version))
	}
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovServer(uint64(l))
	}
	if len(m.Attributes) > 0 {
		for k, v := range m.Attributes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovServer(uint64(l))
			}
			mapEntrySize := 1 + sovServer(uint64(k)) + l
			n += mapEntrySize + 1 + sovServer(uint64(mapEntrySize))
		}
	}
	if len(m.KeyBlobs) > 0 {
		for _, b := range m.KeyBlobs {
			l = len(b)
			n += 1 + l + sovServer(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovServer(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozServer(x uint64) (n int) {
	return sovServer(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GenerateRandomRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenerateRandomRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenerateRandomRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Len", wireType)
			}
			m.Len = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Len |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenerateRandomResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenerateRandomResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenerateRandomResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rnd", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rnd = append(m.Rnd[:0], dAtA[iNdEx:postIndex]...)
			if m.Rnd == nil {
				m.Rnd = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DigestInitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DigestInitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DigestInitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mech", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mech == nil {
				m.Mech = &Mechanism{}
			}
			if err := m.Mech.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DigestInitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DigestInitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DigestInitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DigestRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DigestRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DigestRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DigestResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DigestResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DigestResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Digest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Digest = append(m.Digest[:0], dAtA[iNdEx:postIndex]...)
			if m.Digest == nil {
				m.Digest = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DigestUpdateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DigestUpdateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DigestUpdateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DigestUpdateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DigestUpdateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DigestUpdateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DigestKeyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DigestKeyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DigestKeyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DigestKeyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DigestKeyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DigestKeyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DigestFinalRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DigestFinalRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DigestFinalRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DigestFinalResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DigestFinalResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DigestFinalResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Digest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Digest = append(m.Digest[:0], dAtA[iNdEx:postIndex]...)
			if m.Digest == nil {
				m.Digest = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DigestSingleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DigestSingleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DigestSingleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mech", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mech == nil {
				m.Mech = &Mechanism{}
			}
			if err := m.Mech.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DigestSingleResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DigestSingleResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DigestSingleResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Digest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Digest = append(m.Digest[:0], dAtA[iNdEx:postIndex]...)
			if m.Digest == nil {
				m.Digest = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptInitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptInitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptInitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mech", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mech == nil {
				m.Mech = &Mechanism{}
			}
			if err := m.Mech.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptInitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptInitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptInitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecryptInitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecryptInitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecryptInitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mech", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mech == nil {
				m.Mech = &Mechanism{}
			}
			if err := m.Mech.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecryptInitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecryptInitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecryptInitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptUpdateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptUpdateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptUpdateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plain", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Plain = append(m.Plain[:0], dAtA[iNdEx:postIndex]...)
			if m.Plain == nil {
				m.Plain = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptUpdateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptUpdateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptUpdateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ciphered", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ciphered = append(m.Ciphered[:0], dAtA[iNdEx:postIndex]...)
			if m.Ciphered == nil {
				m.Ciphered = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecryptUpdateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecryptUpdateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecryptUpdateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ciphered", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ciphered = append(m.Ciphered[:0], dAtA[iNdEx:postIndex]...)
			if m.Ciphered == nil {
				m.Ciphered = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecryptUpdateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecryptUpdateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecryptUpdateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plain", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Plain = append(m.Plain[:0], dAtA[iNdEx:postIndex]...)
			if m.Plain == nil {
				m.Plain = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plain", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Plain = append(m.Plain[:0], dAtA[iNdEx:postIndex]...)
			if m.Plain == nil {
				m.Plain = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ciphered", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ciphered = append(m.Ciphered[:0], dAtA[iNdEx:postIndex]...)
			if m.Ciphered == nil {
				m.Ciphered = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecryptRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecryptRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecryptRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ciphered", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ciphered = append(m.Ciphered[:0], dAtA[iNdEx:postIndex]...)
			if m.Ciphered == nil {
				m.Ciphered = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecryptResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecryptResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecryptResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plain", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Plain = append(m.Plain[:0], dAtA[iNdEx:postIndex]...)
			if m.Plain == nil {
				m.Plain = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptFinalRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptFinalRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptFinalRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptFinalResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptFinalResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptFinalResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ciphered", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ciphered = append(m.Ciphered[:0], dAtA[iNdEx:postIndex]...)
			if m.Ciphered == nil {
				m.Ciphered = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecryptFinalRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecryptFinalRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecryptFinalRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecryptFinalResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecryptFinalResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecryptFinalResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plain", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Plain = append(m.Plain[:0], dAtA[iNdEx:postIndex]...)
			if m.Plain == nil {
				m.Plain = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptSingleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptSingleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptSingleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mech", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mech == nil {
				m.Mech = &Mechanism{}
			}
			if err := m.Mech.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plain", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Plain = append(m.Plain[:0], dAtA[iNdEx:postIndex]...)
			if m.Plain == nil {
				m.Plain = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptSingleResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptSingleResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptSingleResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ciphered", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ciphered = append(m.Ciphered[:0], dAtA[iNdEx:postIndex]...)
			if m.Ciphered == nil {
				m.Ciphered = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecryptSingleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecryptSingleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecryptSingleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mech", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mech == nil {
				m.Mech = &Mechanism{}
			}
			if err := m.Mech.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ciphered", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ciphered = append(m.Ciphered[:0], dAtA[iNdEx:postIndex]...)
			if m.Ciphered == nil {
				m.Ciphered = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecryptSingleResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecryptSingleResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecryptSingleResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plain", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Plain = append(m.Plain[:0], dAtA[iNdEx:postIndex]...)
			if m.Plain == nil {
				m.Plain = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignInitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignInitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignInitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mech", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mech == nil {
				m.Mech = &Mechanism{}
			}
			if err := m.Mech.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivKey = append(m.PrivKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PrivKey == nil {
				m.PrivKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignInitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignInitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignInitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyInitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyInitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyInitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mech", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mech == nil {
				m.Mech = &Mechanism{}
			}
			if err := m.Mech.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = append(m.PubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubKey == nil {
				m.PubKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyInitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyInitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyInitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignUpdateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignUpdateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignUpdateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignUpdateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignUpdateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignUpdateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyUpdateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyUpdateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyUpdateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyUpdateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyUpdateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyUpdateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignFinalRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignFinalRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignFinalRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignFinalResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignFinalResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignFinalResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyFinalRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyFinalRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyFinalRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyFinalResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyFinalResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyFinalResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignSingleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignSingleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignSingleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivKey = append(m.PrivKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PrivKey == nil {
				m.PrivKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mech", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mech == nil {
				m.Mech = &Mechanism{}
			}
			if err := m.Mech.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignSingleResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignSingleResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignSingleResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifySingleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifySingleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifySingleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = append(m.PubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubKey == nil {
				m.PubKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mech", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mech == nil {
				m.Mech = &Mechanism{}
			}
			if err := m.Mech.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifySingleResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifySingleResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifySingleResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenerateKeyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenerateKeyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenerateKeyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mech", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mech == nil {
				m.Mech = &Mechanism{}
			}
			if err := m.Mech.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Template", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Template == nil {
				m.Template = make(map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute]*AttributeValue)
			}
			var mapkey uint64
			var mapvalue *AttributeValue
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthServer
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthServer
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &AttributeValue{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Template[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute(mapkey)] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenerateKeyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenerateKeyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenerateKeyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyBytes = append(m.KeyBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.KeyBytes == nil {
				m.KeyBytes = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckSum", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CheckSum = append(m.CheckSum[:0], dAtA[iNdEx:postIndex]...)
			if m.CheckSum == nil {
				m.CheckSum = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = &KeyBlob{}
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenerateKeyPairRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenerateKeyPairRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenerateKeyPairRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mech", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mech == nil {
				m.Mech = &Mechanism{}
			}
			if err := m.Mech.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivKeyTemplate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrivKeyTemplate == nil {
				m.PrivKeyTemplate = make(map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute]*AttributeValue)
			}
			var mapkey uint64
			var mapvalue *AttributeValue
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthServer
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthServer
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &AttributeValue{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PrivKeyTemplate[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute(mapkey)] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKeyTemplate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PubKeyTemplate == nil {
				m.PubKeyTemplate = make(map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute]*AttributeValue)
			}
			var mapkey uint64
			var mapvalue *AttributeValue
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthServer
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthServer
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &AttributeValue{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PubKeyTemplate[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute(mapkey)] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenerateKeyPairResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenerateKeyPairResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenerateKeyPairResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivKeyBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivKeyBytes = append(m.PrivKeyBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.PrivKeyBytes == nil {
				m.PrivKeyBytes = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKeyBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKeyBytes = append(m.PubKeyBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.PubKeyBytes == nil {
				m.PubKeyBytes = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrivKey == nil {
				m.PrivKey = &KeyBlob{}
			}
			if err := m.PrivKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PubKey == nil {
				m.PubKey = &KeyBlob{}
			}
			if err := m.PubKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WrapKeyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WrapKeyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WrapKeyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeK", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeK = append(m.KeK[:0], dAtA[iNdEx:postIndex]...)
			if m.KeK == nil {
				m.KeK = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacKey = append(m.MacKey[:0], dAtA[iNdEx:postIndex]...)
			if m.MacKey == nil {
				m.MacKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mech", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mech == nil {
				m.Mech = &Mechanism{}
			}
			if err := m.Mech.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WrapKeyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WrapKeyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WrapKeyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wrapped", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Wrapped = append(m.Wrapped[:0], dAtA[iNdEx:postIndex]...)
			if m.Wrapped == nil {
				m.Wrapped = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnwrapKeyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnwrapKeyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnwrapKeyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wrapped", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Wrapped = append(m.Wrapped[:0], dAtA[iNdEx:postIndex]...)
			if m.Wrapped == nil {
				m.Wrapped = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeK", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeK = append(m.KeK[:0], dAtA[iNdEx:postIndex]...)
			if m.KeK == nil {
				m.KeK = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacKey = append(m.MacKey[:0], dAtA[iNdEx:postIndex]...)
			if m.MacKey == nil {
				m.MacKey = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mech", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mech == nil {
				m.Mech = &Mechanism{}
			}
			if err := m.Mech.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Template", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Template == nil {
				m.Template = make(map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute]*AttributeValue)
			}
			var mapkey uint64
			var mapvalue *AttributeValue
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthServer
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthServer
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &AttributeValue{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Template[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute(mapkey)] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnwrapKeyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnwrapKeyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnwrapKeyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnwrappedBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnwrappedBytes = append(m.UnwrappedBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.UnwrappedBytes == nil {
				m.UnwrappedBytes = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckSum", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CheckSum = append(m.CheckSum[:0], dAtA[iNdEx:postIndex]...)
			if m.CheckSum == nil {
				m.CheckSum = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unwrapped", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Unwrapped == nil {
				m.Unwrapped = &KeyBlob{}
			}
			if err := m.Unwrapped.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveKeyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeriveKeyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeriveKeyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mech", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mech == nil {
				m.Mech = &Mechanism{}
			}
			if err := m.Mech.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseKey = append(m.BaseKey[:0], dAtA[iNdEx:postIndex]...)
			if m.BaseKey == nil {
				m.BaseKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Template", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Template == nil {
				m.Template = make(map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute]*AttributeValue)
			}
			var mapkey uint64
			var mapvalue *AttributeValue
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthServer
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthServer
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &AttributeValue{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Template[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute(mapkey)] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeriveKeyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeriveKeyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeriveKeyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewKeyBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewKeyBytes = append(m.NewKeyBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.NewKeyBytes == nil {
				m.NewKeyBytes = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckSum", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CheckSum = append(m.CheckSum[:0], dAtA[iNdEx:postIndex]...)
			if m.CheckSum == nil {
				m.CheckSum = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewKey == nil {
				m.NewKey = &KeyBlob{}
			}
			if err := m.NewKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMechanismListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMechanismListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMechanismListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMechanismListResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMechanismListResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMechanismListResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType == 0 {
				var v github_com_IBM_Cloud_hpcs_grep11_go_ep11.Mechanism
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_IBM_Cloud_hpcs_grep11_go_ep11.Mechanism(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Mechs = append(m.Mechs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthServer
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthServer
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Mechs) == 0 {
					m.Mechs = make([]github_com_IBM_Cloud_hpcs_grep11_go_ep11.Mechanism, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_IBM_Cloud_hpcs_grep11_go_ep11.Mechanism
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_IBM_Cloud_hpcs_grep11_go_ep11.Mechanism(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Mechs = append(m.Mechs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Mechs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMechanismInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMechanismInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMechanismInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mech", wireType)
			}
			m.Mech = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mech |= github_com_IBM_Cloud_hpcs_grep11_go_ep11.Mechanism(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMechanismInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMechanismInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMechanismInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MechInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MechInfo == nil {
				m.MechInfo = &MechanismInfo{}
			}
			if err := m.MechInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAttributeValueRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAttributeValueRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAttributeValueRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Object = append(m.Object[:0], dAtA[iNdEx:postIndex]...)
			if m.Object == nil {
				m.Object = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributesBytes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AttributesBytes == nil {
				m.AttributesBytes = make(map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute][]byte)
			}
			var mapkey uint64
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthServer
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthServer
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AttributesBytes[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute(mapkey)] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attributes == nil {
				m.Attributes = make(map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute]*AttributeValue)
			}
			var mapkey uint64
			var mapvalue *AttributeValue
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthServer
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthServer
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &AttributeValue{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Attributes[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute(mapkey)] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAttributeValueResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAttributeValueResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAttributeValueResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributesBytes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AttributesBytes == nil {
				m.AttributesBytes = make(map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute][]byte)
			}
			var mapkey uint64
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthServer
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthServer
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AttributesBytes[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute(mapkey)] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attributes == nil {
				m.Attributes = make(map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute]*AttributeValue)
			}
			var mapkey uint64
			var mapvalue *AttributeValue
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthServer
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthServer
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &AttributeValue{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Attributes[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute(mapkey)] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetAttributeValueRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetAttributeValueRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetAttributeValueRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Object = append(m.Object[:0], dAtA[iNdEx:postIndex]...)
			if m.Object == nil {
				m.Object = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attributes == nil {
				m.Attributes = make(map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute]*AttributeValue)
			}
			var mapkey uint64
			var mapvalue *AttributeValue
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthServer
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthServer
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &AttributeValue{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Attributes[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute(mapkey)] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetAttributeValueResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetAttributeValueResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetAttributeValueResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Object = append(m.Object[:0], dAtA[iNdEx:postIndex]...)
			if m.Object == nil {
				m.Object = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Storeid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Storeid = append(m.Storeid[:0], dAtA[iNdEx:postIndex]...)
			if m.Storeid == nil {
				m.Storeid = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pin = append(m.Pin[:0], dAtA[iNdEx:postIndex]...)
			if m.Pin == nil {
				m.Pin = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pinblob", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pinblob = append(m.Pinblob[:0], dAtA[iNdEx:postIndex]...)
			if m.Pinblob == nil {
				m.Pinblob = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogoutRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogoutRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogoutRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogoutResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogoutResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogoutResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Mechanism) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Mechanism: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Mechanism: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mechanism", wireType)
			}
			m.Mechanism = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mechanism |= github_com_IBM_Cloud_hpcs_grep11_go_ep11.Mechanism(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParameterB", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Parameter = &Mechanism_ParameterB{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RSAOAEPParameter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RSAOAEPParm{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Parameter = &Mechanism_RSAOAEPParameter{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RSAPSSParameter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RSAPSSParm{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Parameter = &Mechanism_RSAPSSParameter{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ECDH1DeriveParameter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ECDH1DeriveParm{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Parameter = &Mechanism_ECDH1DeriveParameter{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MechanismInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MechanismInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MechanismInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinKeySize", wireType)
			}
			m.MinKeySize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinKeySize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxKeySize", wireType)
			}
			m.MaxKeySize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxKeySize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Grep11Error) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Grep11Error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Grep11Error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= github_com_IBM_Cloud_hpcs_grep11_go_ep11.Return(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Detail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retry", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Retry = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RSAOAEPParm) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RSAOAEPParm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RSAOAEPParm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashMech", wireType)
			}
			m.HashMech = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HashMech |= github_com_IBM_Cloud_hpcs_grep11_go_ep11.Mechanism(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mgf", wireType)
			}
			m.Mgf = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mgf |= RSAOAEPParm_Mask(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncodingParmType", wireType)
			}
			m.EncodingParmType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EncodingParmType |= RSAOAEPParm_ParmType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncodingParm", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncodingParm = append(m.EncodingParm[:0], dAtA[iNdEx:postIndex]...)
			if m.EncodingParm == nil {
				m.EncodingParm = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RSAPSSParm) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RSAPSSParm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RSAPSSParm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashMech", wireType)
			}
			m.HashMech = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HashMech |= github_com_IBM_Cloud_hpcs_grep11_go_ep11.Mechanism(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mgf", wireType)
			}
			m.Mgf = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mgf |= RSAPSSParm_Mask(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaltByteCount", wireType)
			}
			m.SaltByteCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SaltByteCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ECDH1DeriveParm) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ECDH1DeriveParm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ECDH1DeriveParm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kdf", wireType)
			}
			m.Kdf = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kdf |= ECDH1DeriveParm_KeyDerivationFunction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharedData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SharedData = append(m.SharedData[:0], dAtA[iNdEx:postIndex]...)
			if m.SharedData == nil {
				m.SharedData = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicData = append(m.PublicData[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicData == nil {
				m.PublicData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HMACGeneralParm) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HMACGeneralParm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HMACGeneralParm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReturnByteCount", wireType)
			}
			m.ReturnByteCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReturnByteCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewrapKeyBlobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewrapKeyBlobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewrapKeyBlobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WrappedKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WrappedKey = append(m.WrappedKey[:0], dAtA[iNdEx:postIndex]...)
			if m.WrappedKey == nil {
				m.WrappedKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewrapKeyBlobResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewrapKeyBlobResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewrapKeyBlobResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewrappedKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewrappedKey = append(m.RewrappedKey[:0], dAtA[iNdEx:postIndex]...)
			if m.RewrappedKey == nil {
				m.RewrappedKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyBlob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyBlob == nil {
				m.KeyBlob = &KeyBlob{}
			}
			if err := m.KeyBlob.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttributeValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttributeValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttributeValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributeB", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.OneAttr = &AttributeValue_AttributeB{v}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributeTF", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.OneAttr = &AttributeValue_AttributeTF{b}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributeI", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OneAttr = &AttributeValue_AttributeI{v}
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyBlob) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyBlob: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyBlob: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyBlobID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyBlobID = append(m.KeyBlobID[:0], dAtA[iNdEx:postIndex]...)
			if m.KeyBlobID == nil {
				m.KeyBlobID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = append(m.TxID[:0], dAtA[iNdEx:postIndex]...)
			if m.TxID == nil {
				m.TxID = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attributes == nil {
				m.Attributes = make(map[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute]*AttributeValue)
			}
			var mapkey uint64
			var mapvalue *AttributeValue
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthServer
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthServer
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &AttributeValue{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipServer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthServer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Attributes[github_com_IBM_Cloud_hpcs_grep11_go_ep11.Attribute(mapkey)] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyBlobs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthServer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyBlobs = append(m.KeyBlobs, make([]byte, postIndex-iNdEx))
			copy(m.KeyBlobs[len(m.KeyBlobs)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipServer(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowServer
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowServer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowServer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthServer
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupServer
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthServer
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthServer        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowServer          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupServer = fmt.Errorf("proto: unexpected end of group")
)
